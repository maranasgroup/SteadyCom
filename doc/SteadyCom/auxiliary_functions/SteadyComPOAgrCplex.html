<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SteadyComPOAgrCplex</title>
  <meta name="keywords" content="SteadyComPOAgrCplex">
  <meta name="description" content="Pairwise POA for community model at community steady-state at a given growth rate">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html SteadyCom --><!-- menu.html auxiliary_functions -->
<h1>SteadyComPOAgrCplex
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Pairwise POA for community model at community steady-state at a given growth rate</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [POAtable, fluxRange, Stat, pairList] = SteadyComPOAgrCplex(modelCom,options,solverParam,LP) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Pairwise POA for community model at community steady-state at a given growth rate
[POAtable, fluxRange, Stat, pairList] = SteadyComPOAgrCplex(modelCom,options,solverParam,LP)

INPUT
 modelCom        a community COBRA model structure with the following extra fields:
 (the following fields are required - others can be supplied)
   S            Stoichiometric matrix
   b            Right hand side
   c            Objective coefficients
   lb           Lower bounds
   ub           Upper bounds
 (at least one of the below two is needed)
   infoCom      structure containing community reaction info 
                (returned along with the community model created with createCommModel)
   indCom       the index structure corresponding to infoCom

 options (optional) option structure with the following fields:
   GR              The growth rate at which POA is performed. If not
                     given, find the maximum growth rate.
   optBMpercent    Only consider solutions that yield at least a certain
                     percentage of the optimal biomass (Default = 95)
   rxnNameList     List of reactions (IDs or .rxns) to be analyzed.
                     Use a (N_rxns + N_organism) x K matrix for POA of K
                     linear combinations of fluxes and/or abundances
                     (Default = biomass reaction of each species)
   pairList        Pairs in rxnNameList to be analyzed. N_pair by 2 array of:
                     - indices referring to the rxns in rxnNameList, e.g.,
                       [1 2] to analyze rxnNameList{1} vs rxnNameList{2}
                     - rxn names which are members of rxnNameList, e.g.,
                       {'EX_glc-D(e)','EX_ac(e)'}
                     If not supplied, analyze all K(K-1) pairs from the K
                     targets in rxnNameList.
   symmetric       Used only when pairList is not supplied. Avoid running 
                     symmetric pairs (e.g. j vs k and k vs j)
   Nstep           Number of steps for fixing one flux at a value between 
                     the min. and the max. possible fluxes. Default 10.
                   Can also be a vector indicating the fraction of intermediate value to be analyzed
                   e.g. [0 0.5 1] means computing at minFlux, 0.5(minFlux + maxFlux) and maxFlux
   NstepScale      Used only when Nstep is a single number. 
                     -'lin' for a linear (uniform) scale of step size 
                     -'log' for a log scaling of the step sizes
   fluxRange       Flux range for each entry in rxnNameList. K x 2 matrix.
                   Defaulted to be found by SteadyComFVACplex.m
  (other parameters)
   savePOA         Must be non-empty. The filename to save the POA results
                   (default 'POAtmp/POA')
   threads         &gt; 1 for explicitly stating the no. of threads used,
                   0 or -1 for using all available threads. Default 1.
   verbFlag        Verbose output. 0 or 1.
   loadModel       String of filename to be loaded. If non-empty, load the 
                   cplex model ('loadModel.mps'), basis ('loadModel.bas') 
                   and parameters ('loadModel.prm').
  May add also other parameters in SteadyComCplex for calculating the maximum growth rate.

OUTPUT
 POAtable          K x K cells. 
                   (i,i)-cell contains the flux range of rxnNameList{i}
                   (i,j)-cell contains a Nstep x 2 matrix, with (k,1)-entry 
                   being the min of rxnNameList{j} when rxnNameList{i} is 
                   fixed at the k-th value, (k,2)-entry being the max.
 fluxRange         K x 2 matrix of flux range for each entry in rxnNameList 
 Stat              K x K structure array with fields:
                     -'cor': the slope from linear regression between the
                             fluxes of a pair
                     -'r2':  the corresponding coefficient of determination (R-square)
 pairList          pairList after transformation from various input formats</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../SteadyCom/SteadyComCplex.html" class="code" title="function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP)">SteadyComCplex</a>	Find the maximum community growth rate at community steady-state using SteadyCom</li><li><a href="SteadyComFVAgrCplex.html" class="code" title="function [minFlux,maxFlux,minFD,maxFD,LP,GR] = SteadyComFVAgrCplex(modelCom,options,solverParam,LP)">SteadyComFVAgrCplex</a>	Flux variability analysis for community model at community steady-state at a given growth rate.</li><li><a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>	Check the feasibility of a solution given a COBRA model structure or a CPLEX dynamic object and a solution</li><li><a href="getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>	get the required default parameters</li><li><a href="infoCom2indCom.html" class="code" title="function indCom = infoCom2indCom(modelCom,infoCom,revFlag,spAbbr,spName)">infoCom2indCom</a>	Transform between community reaction IDs and reaction names</li><li><a href="setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>	Set the parameters of the CPLEX object according to the structure solverParam</li><li><a href="updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>	Create and update the SteadyCom LP model in CPLEX format.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../SteadyCom/SteadyComPOACplex.html" class="code" title="function [POAtable, fluxRange, Stat, GRvector] = SteadyComPOACplex(modelCom,options,solverParam)">SteadyComPOACplex</a>	Pairwise POA for community model at community steady-state for a range of growth rates</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function iSave(savePOA,POAtableJK,StatJK,GR,j0,k0)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [POAtable, fluxRange, Stat, pairList] = SteadyComPOAgrCplex(modelCom,options,solverParam,LP)</a>
0002 <span class="comment">%Pairwise POA for community model at community steady-state at a given growth rate</span>
0003 <span class="comment">%[POAtable, fluxRange, Stat, pairList] = SteadyComPOAgrCplex(modelCom,options,solverParam,LP)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%INPUT</span>
0006 <span class="comment">% modelCom        a community COBRA model structure with the following extra fields:</span>
0007 <span class="comment">% (the following fields are required - others can be supplied)</span>
0008 <span class="comment">%   S            Stoichiometric matrix</span>
0009 <span class="comment">%   b            Right hand side</span>
0010 <span class="comment">%   c            Objective coefficients</span>
0011 <span class="comment">%   lb           Lower bounds</span>
0012 <span class="comment">%   ub           Upper bounds</span>
0013 <span class="comment">% (at least one of the below two is needed)</span>
0014 <span class="comment">%   infoCom      structure containing community reaction info</span>
0015 <span class="comment">%                (returned along with the community model created with createCommModel)</span>
0016 <span class="comment">%   indCom       the index structure corresponding to infoCom</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% options (optional) option structure with the following fields:</span>
0019 <span class="comment">%   GR              The growth rate at which POA is performed. If not</span>
0020 <span class="comment">%                     given, find the maximum growth rate.</span>
0021 <span class="comment">%   optBMpercent    Only consider solutions that yield at least a certain</span>
0022 <span class="comment">%                     percentage of the optimal biomass (Default = 95)</span>
0023 <span class="comment">%   rxnNameList     List of reactions (IDs or .rxns) to be analyzed.</span>
0024 <span class="comment">%                     Use a (N_rxns + N_organism) x K matrix for POA of K</span>
0025 <span class="comment">%                     linear combinations of fluxes and/or abundances</span>
0026 <span class="comment">%                     (Default = biomass reaction of each species)</span>
0027 <span class="comment">%   pairList        Pairs in rxnNameList to be analyzed. N_pair by 2 array of:</span>
0028 <span class="comment">%                     - indices referring to the rxns in rxnNameList, e.g.,</span>
0029 <span class="comment">%                       [1 2] to analyze rxnNameList{1} vs rxnNameList{2}</span>
0030 <span class="comment">%                     - rxn names which are members of rxnNameList, e.g.,</span>
0031 <span class="comment">%                       {'EX_glc-D(e)','EX_ac(e)'}</span>
0032 <span class="comment">%                     If not supplied, analyze all K(K-1) pairs from the K</span>
0033 <span class="comment">%                     targets in rxnNameList.</span>
0034 <span class="comment">%   symmetric       Used only when pairList is not supplied. Avoid running</span>
0035 <span class="comment">%                     symmetric pairs (e.g. j vs k and k vs j)</span>
0036 <span class="comment">%   Nstep           Number of steps for fixing one flux at a value between</span>
0037 <span class="comment">%                     the min. and the max. possible fluxes. Default 10.</span>
0038 <span class="comment">%                   Can also be a vector indicating the fraction of intermediate value to be analyzed</span>
0039 <span class="comment">%                   e.g. [0 0.5 1] means computing at minFlux, 0.5(minFlux + maxFlux) and maxFlux</span>
0040 <span class="comment">%   NstepScale      Used only when Nstep is a single number.</span>
0041 <span class="comment">%                     -'lin' for a linear (uniform) scale of step size</span>
0042 <span class="comment">%                     -'log' for a log scaling of the step sizes</span>
0043 <span class="comment">%   fluxRange       Flux range for each entry in rxnNameList. K x 2 matrix.</span>
0044 <span class="comment">%                   Defaulted to be found by SteadyComFVACplex.m</span>
0045 <span class="comment">%  (other parameters)</span>
0046 <span class="comment">%   savePOA         Must be non-empty. The filename to save the POA results</span>
0047 <span class="comment">%                   (default 'POAtmp/POA')</span>
0048 <span class="comment">%   threads         &gt; 1 for explicitly stating the no. of threads used,</span>
0049 <span class="comment">%                   0 or -1 for using all available threads. Default 1.</span>
0050 <span class="comment">%   verbFlag        Verbose output. 0 or 1.</span>
0051 <span class="comment">%   loadModel       String of filename to be loaded. If non-empty, load the</span>
0052 <span class="comment">%                   cplex model ('loadModel.mps'), basis ('loadModel.bas')</span>
0053 <span class="comment">%                   and parameters ('loadModel.prm').</span>
0054 <span class="comment">%  May add also other parameters in SteadyComCplex for calculating the maximum growth rate.</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%OUTPUT</span>
0057 <span class="comment">% POAtable          K x K cells.</span>
0058 <span class="comment">%                   (i,i)-cell contains the flux range of rxnNameList{i}</span>
0059 <span class="comment">%                   (i,j)-cell contains a Nstep x 2 matrix, with (k,1)-entry</span>
0060 <span class="comment">%                   being the min of rxnNameList{j} when rxnNameList{i} is</span>
0061 <span class="comment">%                   fixed at the k-th value, (k,2)-entry being the max.</span>
0062 <span class="comment">% fluxRange         K x 2 matrix of flux range for each entry in rxnNameList</span>
0063 <span class="comment">% Stat              K x K structure array with fields:</span>
0064 <span class="comment">%                     -'cor': the slope from linear regression between the</span>
0065 <span class="comment">%                             fluxes of a pair</span>
0066 <span class="comment">%                     -'r2':  the corresponding coefficient of determination (R-square)</span>
0067 <span class="comment">% pairList          pairList after transformation from various input formats</span>
0068 
0069 <span class="comment">%% Initialization</span>
0070 <span class="comment">%check required fields for community model</span>
0071 <span class="keyword">if</span> ~isfield(modelCom,<span class="string">'indCom'</span>)
0072     <span class="keyword">if</span> ~isfield(modelCom,<span class="string">'infoCom'</span>) || ~isstruct(modelCom.infoCom) || <span class="keyword">...</span>
0073             ~all(isfield(modelCom.infoCom,{<span class="string">'spBm'</span>,<span class="string">'EXcom'</span>,<span class="string">'EXsp'</span>,<span class="string">'spAbbr'</span>,<span class="string">'rxnSps'</span>,<span class="string">'metSps'</span>}))
0074         error(<span class="string">'infoCom must be provided for calculating the max. community growth rate.\n'</span>);
0075     <span class="keyword">end</span>
0076     <span class="comment">%get useful reaction indices</span>
0077     modelCom.indCom = <a href="infoCom2indCom.html" class="code" title="function indCom = infoCom2indCom(modelCom,infoCom,revFlag,spAbbr,spName)">infoCom2indCom</a>(modelCom);
0078 <span class="keyword">end</span>
0079 
0080 <span class="comment">%get paramters</span>
0081 <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>)
0082     options = struct();
0083 <span class="keyword">end</span>
0084 <span class="keyword">if</span> ~exist(<span class="string">'solverParam'</span>, <span class="string">'var'</span>) || isempty(solverParam)
0085     <span class="comment">%default Cplex parameters</span>
0086     solverParam = <a href="getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>(<span class="string">'CplexParam'</span>);
0087 <span class="keyword">end</span>
0088 param2get = {<span class="string">'GRfx'</span>,<span class="string">'GR'</span>, <span class="string">'BMmaxLB'</span>,<span class="string">'BMmaxUB'</span>,<span class="string">'optBMpercent'</span>,<span class="keyword">...</span><span class="comment"> %parameters for finding maximum growth rate</span>
0089              <span class="string">'symmetric'</span>,<span class="string">'rxnNameList'</span>,<span class="string">'pairList'</span>, <span class="string">'fluxRange'</span>, <span class="string">'Nstep'</span>, <span class="string">'NstepScale'</span>,<span class="keyword">...</span><span class="comment"> %parameters for POA</span>
0090              <span class="string">'verbFlag'</span>, <span class="string">'threads'</span>, <span class="string">'savePOA'</span>,<span class="string">'loadModel'</span>,<span class="keyword">...</span>
0091              };
0092 eval(sprintf(<span class="string">'[%s] = getCobraComParams(param2get, options, modelCom);'</span>, <span class="keyword">...</span>
0093     strjoin(param2get, <span class="string">','</span>)<span class="keyword">...</span>
0094     )<span class="keyword">...</span>
0095     );
0096 <span class="keyword">if</span> isempty(savePOA)
0097     <span class="comment">%always use save option to reduce memory need</span>
0098     savePOA = <span class="string">'POAtmp/POA'</span>;
0099 <span class="keyword">end</span>
0100 directory = strsplit(savePOA,filesep);
0101 <span class="keyword">if</span> numel(directory) &gt; 1
0102     <span class="comment">%not saving in the current directory. Check existence</span>
0103     directory = strjoin(directory(1:end-1),filesep);
0104     <span class="keyword">if</span> ~exist(directory,<span class="string">'dir'</span>)
0105         mkdir(directory);
0106     <span class="keyword">end</span>
0107 <span class="keyword">end</span>
0108 [feasTol, ~] = getCobraSolverParams(<span class="string">'LP'</span>,{<span class="string">'feasTol'</span>; <span class="string">'optTol'</span>}, solverParam);
0109 <span class="keyword">if</span> isfield(solverParam,<span class="string">'simplex'</span>) &amp;&amp; isfield(solverParam.simplex, <span class="string">'tolerances'</span>)<span class="keyword">...</span>
0110         &amp;&amp; isfield(solverParam.simplex.tolerances,<span class="string">'feasibility'</span>)
0111     <span class="comment">%override the feasTol in CobraSolverParam if given in solverParam</span>
0112     feasTol = solverParam.simplex.tolerances.feasibility;
0113 <span class="keyword">else</span>
0114     <span class="comment">%otherwise use that in the solver</span>
0115     solverParam.simplex.tolerances.feasibility = feasTol;
0116 <span class="keyword">end</span>
0117 
0118 <span class="comment">%Check if the whole computation been finished before</span>
0119 <span class="keyword">if</span> ~isempty(savePOA)
0120     <span class="keyword">if</span> exist(sprintf(<span class="string">'%s.mat'</span>,savePOA), <span class="string">'file'</span>)
0121         data0 = load(sprintf(<span class="string">'%s.mat'</span>,savePOA));
0122         <span class="keyword">if</span> isfield(data0, <span class="string">'finished'</span>)
0123             <span class="keyword">if</span> verbFlag
0124                 fprintf(<span class="string">'Already finished. Results loaded from %s.mat\n'</span>,savePOA);
0125             <span class="keyword">end</span>
0126             load(sprintf(<span class="string">'%s.mat'</span>,savePOA), <span class="string">'POAtable'</span>, <span class="string">'fluxRange'</span>, <span class="string">'Stat'</span>)
0127             <span class="keyword">return</span>
0128         <span class="keyword">else</span>
0129             clear data0
0130         <span class="keyword">end</span>
0131     <span class="keyword">end</span>
0132 <span class="keyword">end</span>
0133 
0134 <span class="comment">%parallel computation</span>
0135 <span class="keyword">if</span> isempty(gcp(<span class="string">'nocreate'</span>))
0136     <span class="keyword">if</span> threads &gt; 1
0137         <span class="comment">%given explicit no. of threads</span>
0138         parpool(ceil(threads));
0139     <span class="keyword">elseif</span> threads ~= 1
0140         <span class="comment">%default max no. of threads (input 0 or -1 etc)</span>
0141         parpool;
0142     <span class="keyword">end</span>
0143 <span class="keyword">end</span>
0144 <span class="comment">%sizes</span>
0145 [m, n] = size(modelCom.S);
0146 nRxnSp = sum(modelCom.indCom.rxnSps &gt; 0); <span class="comment">%number of species-specific rxns</span>
0147 nSp = numel(modelCom.indCom.spBm); <span class="comment">%number of species</span>
0148 
0149 <span class="comment">%% handle LP structure</span>
0150 checkBMrow = false;
0151 <span class="keyword">if</span> isempty(GR)
0152     <span class="comment">%if max growth rate not given, find it and get the LP problem</span>
0153     options2 = options;
0154     options2.minNorm = false;
0155     [~, result,LP] = <a href="../../SteadyCom/SteadyComCplex.html" class="code" title="function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP)">SteadyComCplex</a>(modelCom, options2, solverParam);
0156     GR = result.GRmax;
0157     idRow = size(LP.Model.A,1);
0158     addRow = false;
0159 <span class="keyword">elseif</span> nargin &lt; 4
0160     <span class="keyword">if</span> ~isempty(loadModel)
0161         <span class="comment">% load solution if given and growth rate is known</span>
0162         LP = Cplex(<span class="string">'poa'</span>);
0163         LP.readModel([loadSol <span class="string">'.mps'</span>]);
0164         LP.readBasis([loadSol <span class="string">'.bas'</span>]);
0165         LP.readParam([loadSol <span class="string">'.prm'</span>]);
0166         fprintf(<span class="string">'Load model ''%s'' successfully.\n'</span>, loadModel);
0167         checkBMrow = true;
0168     <span class="keyword">else</span>
0169         <span class="comment">%get LP using optimizeCbModelComCplex if only growth rate is given</span>
0170         options2 = options;
0171         options2.LPonly = true;
0172         [~, ~, LP] = <a href="../../SteadyCom/SteadyComCplex.html" class="code" title="function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP)">SteadyComCplex</a>(modelCom, options2, solverParam);
0173         addRow = true;
0174     <span class="keyword">end</span>
0175 <span class="keyword">else</span>
0176     checkBMrow = true;
0177 <span class="keyword">end</span>
0178 
0179 <span class="keyword">if</span> checkBMrow &amp;&amp; size(LP.Model.A,1) &gt; m + 2*nRxnSp + nSp
0180     <span class="comment">%if a row constraining the sum of biomass exists</span>
0181     [ynRow,idRow] = ismember(sparse(ones(nSp,1),n+1:n+nSp,ones(nSp,1),1,n+nSp),<span class="keyword">...</span>
0182             LP.Model.A(m+2*nRxnSp+nSp+1:<span class="keyword">end</span>,1:n+nSp),<span class="string">'rows'</span>);
0183     <span class="keyword">if</span> ynRow
0184         idRow = m + 2*nRxnSp + nSp + idRow;
0185     <span class="keyword">end</span>
0186     addRow = ~ynRow;
0187 <span class="keyword">end</span>
0188 <span class="keyword">if</span> addRow
0189     <span class="comment">%add a row for constraining the sum of biomass if not exist</span>
0190     <span class="comment">%using default BMmaxLB and BMmaxUB if not given in options</span>
0191     LP.addRows(BMmaxLB * optBMpercent / 100, <span class="keyword">...</span>
0192         sparse(ones(1, nSp), n + 1: n + nSp, ones(1, nSp), 1, size(LP.Model.A,2)),<span class="keyword">...</span>
0193         BMmaxUB, <span class="string">'UnityBiomass'</span>);
0194     idRow = size(LP.Model.A,1);
0195 <span class="keyword">else</span>
0196     <span class="comment">%using BMmaxLB and BMmaxUB stored in the LP if not given in options</span>
0197     <span class="keyword">if</span> ~isfield(options,<span class="string">'BMmaxLB'</span>) <span class="comment">%take from LP if not supplied</span>
0198         BMmaxLB = LP.Model.lhs(idRow);
0199     <span class="keyword">end</span>
0200     <span class="keyword">if</span> ~isfield(options,<span class="string">'BMmaxUB'</span>) <span class="comment">%take from LP if not supplied</span>
0201         BMmaxUB = LP.Model.rhs(idRow);
0202     <span class="keyword">end</span>
0203     LP.Model.lhs(idRow) = BMmaxLB * optBMpercent / 100;
0204     <span class="comment">%not allow the max. biomass to exceed the one at max growth rate,</span>
0205     <span class="comment">%can happen if optBMpercent &lt; 100. May dismiss this constraint or</span>
0206     <span class="comment">%manually supply BMmaxUB in the options if sum of biomass should be variable</span>
0207     LP.Model.rhs(idRow) = BMmaxUB;
0208 <span class="keyword">end</span>
0209 <span class="comment">%set Cplex parameters</span>
0210 LP = <a href="setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LP, solverParam);
0211 BMmax0 = LP.Model.lhs(idRow);
0212 <span class="comment">%update the LP to ensure the current growth rate is constrained</span>
0213 LP.Model.A = <a href="updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, GR, GRfx, [], LP.Model.A, []);
0214 LP.Model.sense = <span class="string">'minimize'</span>;
0215 LP.Model.obj(:) = 0;
0216 <span class="comment">%number of variables</span>
0217 nVar = size(LP.Model.A,2);
0218 
0219 <span class="comment">%% handle objective matrix</span>
0220 <span class="keyword">if</span> ischar(rxnNameList)
0221     <span class="comment">%treat single character vector as cell with one element</span>
0222     rxnNameList = {rxnNameList};
0223 <span class="keyword">end</span>
0224 <span class="keyword">if</span> isnumeric(rxnNameList)
0225     <span class="keyword">if</span> size(rxnNameList,1) &gt;= n &amp;&amp; size(rxnNameList,1) &lt;= nVar
0226         <span class="comment">%it is a matrix of objective vectors</span>
0227         objList = [sparse(rxnNameList); sparse(nVar - size(rxnNameList,1), size(rxnNameList,2))];
0228     <span class="keyword">elseif</span> size(rxnNameList,1) == 1 || size(rxnNameList,2) == 1 
0229         <span class="comment">%reaction index</span>
0230         objList = sparse(rxnNameList, 1:numel(rxnNameList), ones(numel(rxnNameList),1),<span class="keyword">...</span>
0231             nVar, max(size(rxnNameList)));
0232     <span class="keyword">else</span>
0233         error(<span class="string">'Invalid numerical input of rxnNameList.'</span>);
0234     <span class="keyword">end</span>
0235 <span class="keyword">elseif</span> iscell(rxnNameList)
0236     objList = sparse(nVar, numel(rxnNameList));
0237     <span class="keyword">for</span> jRxnName = 1:numel(rxnNameList)
0238         rJ = findRxnIDs(modelCom,rxnNameList{jRxnName});
0239         <span class="keyword">if</span> ~all(rJ)
0240             error(<span class="string">'Invalid names in rxnNameList'</span>);
0241         <span class="keyword">end</span>
0242         objList(rJ,jRxnName) = 1;
0243     <span class="keyword">end</span>
0244 <span class="keyword">else</span>
0245     error(<span class="string">'Invalid input of rxnNameList'</span>);
0246 <span class="keyword">end</span>
0247 <span class="comment">%number of variables for POA</span>
0248 Ncheck = size(objList,2);
0249 
0250 <span class="comment">%% Handle pairList</span>
0251 <span class="keyword">if</span> isempty(pairList)
0252     <span class="comment">%if pairList not given, run for all pairs</span>
0253     pairList = [reshape(repmat(1:Ncheck,Ncheck,1),Ncheck^2,1), repmat((1:Ncheck)',Ncheck,1)];
0254     <span class="keyword">if</span> symmetric 
0255         <span class="comment">%the option 'symmetric' is only used here when pairList is not</span>
0256         <span class="comment">%supplied to avoid running symmetric pairs (e.g. j vs k and k vs j)</span>
0257         pairList(pairList(:,1) &gt; pairList(:,2),:) = [];
0258     <span class="keyword">end</span>
0259 <span class="keyword">elseif</span> numel(size(pairList)) ~= 2 || size(pairList,2) &lt; 2 
0260     error(<span class="string">'pairList must be an N-by-2 array denoting the pairs (rxn names or indices in rxnNameList) to analyze!'</span>)
0261 <span class="keyword">else</span>
0262     <span class="keyword">if</span> iscell(pairList) 
0263         <span class="keyword">if</span> ~iscell(rxnNameList)
0264             error(<span class="string">'rxnNameList must be cell array of rxn names to match the rxn names in pairList!'</span>);
0265         <span class="keyword">else</span>
0266             <span class="keyword">if</span> iscellstr(pairList) &amp;&amp; iscellstr(rxnNameList)
0267                 <span class="comment">%both are character arrays</span>
0268                 [~,pairId] = ismember(pairList, rxnNameList);
0269             <span class="keyword">else</span>
0270                 <span class="comment">%Need to use isequal</span>
0271                 pairId = zeros(size(pairList));
0272                 <span class="keyword">for</span> jP = 1:numel(pairList)
0273                     <span class="keyword">for</span> jR = 1:numel(rxnNameList)
0274                         <span class="keyword">if</span> isequal(pairList{jP},rxnNameList{jR})
0275                             pairId(jP) = jR;
0276                             <span class="keyword">break</span>
0277                         <span class="keyword">end</span>
0278                     <span class="keyword">end</span>
0279                 <span class="keyword">end</span>
0280             <span class="keyword">end</span>
0281             <span class="keyword">if</span> ~all(all(pairId))
0282                 error(<span class="string">'Some entries in pairList cannot be mapped to rxnNameList!'</span>)
0283             <span class="keyword">end</span>
0284             pairList = pairId;
0285             clear pairId
0286         <span class="keyword">end</span>
0287     <span class="keyword">end</span>  
0288 <span class="keyword">end</span>
0289 Npair = size(pairList,1);
0290 
0291 <span class="comment">%% find pairs in the pairList not analyzed yet</span>
0292 undone = true(Npair,1);
0293 <span class="keyword">if</span> ~isempty(savePOA) 
0294     <span class="keyword">if</span> exist(sprintf(<span class="string">'%s.mat'</span>,savePOA),<span class="string">'file'</span>)
0295         fprintf(<span class="string">'Already finished. Results were already saved to %s.mat\n'</span>,savePOA);
0296         load(sprintf(<span class="string">'%s.mat'</span>,savePOA), <span class="string">'POAtable'</span>, <span class="string">'fluxRange'</span>, <span class="string">'Stat'</span>);
0297         <span class="keyword">return</span>
0298     <span class="keyword">elseif</span> exist(sprintf(<span class="string">'%s_POApre.mat'</span>,savePOA),<span class="string">'file'</span>)
0299         fluxRange = load(sprintf(<span class="string">'%s_POApre.mat'</span>,savePOA),<span class="string">'fluxRange'</span>);
0300         fluxRange = fluxRange.fluxRange;
0301         <span class="keyword">for</span> jP = 1:Npair
0302             undone(jP) = ~exist(sprintf(<span class="string">'%s_j%d_k%d.mat'</span>,savePOA,pairList(jP,1),pairList(jP,2)), <span class="string">'file'</span>);
0303         <span class="keyword">end</span>
0304         fprintf(<span class="string">'Unfinished pairs: %d\n'</span>, sum(undone));
0305     <span class="keyword">end</span>
0306 <span class="keyword">end</span>
0307 
0308 <span class="keyword">if</span> any(undone)
0309     <span class="comment">%% initial solve to ensure feasibility</span>
0310     LP.solve();
0311     <span class="comment">%check and adjust for feasibility</span>
0312     dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0313     kBMadjust = 0;
0314     <span class="keyword">while</span> (~isfield(LP.Solution, <span class="string">'x'</span>) || dev &gt; feasTol) &amp;&amp; kBMadjust &lt; 10
0315         kBMadjust = kBMadjust + 1;
0316         LP.Model.lhs(end) = BMmax0 * (1 - feasTol/(11 - kBMadjust));
0317         LP.solve();
0318         dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0319         <span class="keyword">if</span> verbFlag
0320             fprintf(<span class="string">'BMmax adjusment: %d\n'</span>,kBMadjust);
0321         <span class="keyword">end</span>
0322     <span class="keyword">end</span>
0323     <span class="comment">%terminate if not feasible</span>
0324     <span class="keyword">if</span> (~isfield(LP.Solution, <span class="string">'x'</span>) || dev &gt; feasTol)
0325         error(<span class="string">'Model not feasible.'</span>)
0326     <span class="keyword">end</span>
0327     <span class="comment">%% Find flux range by FVA</span>
0328     <span class="keyword">if</span> isempty(fluxRange)
0329         optionsFVA = options;
0330         optionsFVA.rxnNameList = objList;
0331         optionsFVA.GR = GR;
0332         fluxRange = zeros(size(objList,2),2);
0333         [fluxRange(:,1), fluxRange(:,2)] = <a href="SteadyComFVAgrCplex.html" class="code" title="function [minFlux,maxFlux,minFD,maxFD,LP,GR] = SteadyComFVAgrCplex(modelCom,options,solverParam,LP)">SteadyComFVAgrCplex</a>(modelCom,optionsFVA,solverParam,LP);
0334         printFluxRange = false;
0335         <span class="keyword">if</span> ~isempty(savePOA)
0336             save(sprintf(<span class="string">'%s_POApre.mat'</span>,savePOA),<span class="string">'fluxRange'</span>,<span class="string">'GR'</span>,<span class="string">'options'</span>,<span class="keyword">...</span>
0337                 <span class="string">'objList'</span>,<span class="string">'pairList'</span>,<span class="string">'options'</span>,<span class="string">'solverParam'</span>);
0338         <span class="keyword">end</span>
0339     <span class="keyword">else</span>
0340         printFluxRange = true;
0341     <span class="keyword">end</span>
0342     <span class="comment">%print flux range</span>
0343     <span class="keyword">if</span> verbFlag &amp;&amp; printFluxRange
0344         fprintf(<span class="string">'Flux range:\n'</span>);
0345         fprintf(<span class="string">'rxn\tmin\tmax\n'</span>);
0346         <span class="keyword">for</span> jRxn = 1:size(objList,2)
0347             strPrint = strjoin(strtrim(cellstr(LP.Model.colname(objList(:,jRxn)~=0,:))),<span class="string">','</span>);
0348             fprintf(<span class="string">'%s\t%.6f\t%.6f\n'</span>, strPrint, fluxRange(jRxn,1), fluxRange(jRxn,2));
0349         <span class="keyword">end</span>
0350     <span class="keyword">end</span>
0351     <span class="keyword">if</span> (~isfield(modelCom,<span class="string">'b'</span>))
0352         modelCom.b = zeros(size(modelCom.S,1),1);
0353     <span class="keyword">end</span>
0354     
0355     Npair =sum(undone);
0356     undoneId = find(undone);
0357     
0358     <span class="comment">%print starting point</span>
0359     <span class="keyword">if</span> verbFlag
0360         fprintf(<span class="string">'\nPOA for %d pairs of reactions at growth rate %.6f\n'</span>, <span class="keyword">...</span>
0361             Npair - sum(pairList(undoneId,1)==pairList(undoneId,2)), GR);
0362         strPrintj = strjoin(strtrim(cellstr(LP.Model.colname(objList(:,pairList(undoneId(1),1))~=0,:))),<span class="string">','</span>);
0363         strPrintk = strjoin(strtrim(cellstr(LP.Model.colname(objList(:,pairList(undoneId(1),2))~=0,:))),<span class="string">','</span>);
0364         fprintf(<span class="string">'Start from #%d %s vs #%d %s.\n'</span>, pairList(undoneId(1),1), <span class="keyword">...</span>
0365             strPrintj, pairList(undoneId(1),2), strPrintk);
0366         fprintf(<span class="string">'%15s%15s%10s%10s%10s%10s   %s\n'</span>,<span class="string">'Rxn1'</span>,<span class="string">'Rxn2'</span>,<span class="string">'corMin'</span>,<span class="string">'r2'</span>,<span class="string">'corMax'</span>,<span class="string">'r2'</span>,<span class="string">'Time'</span>)
0367     <span class="keyword">end</span>
0368     lb0 = LP.Model.lb;
0369     ub0 = LP.Model.ub;
0370     addConstraint = false;
0371 
0372     <span class="keyword">if</span> threads == 1
0373         <span class="comment">%% single thread computation</span>
0374         <span class="comment">%Get data points to be computated</span>
0375         
0376         <span class="keyword">for</span> jP = 1:Npair
0377             [j,k] = deal(pairList(undoneId(jP),1),pairList(undoneId(jP),2));
0378             <span class="keyword">if</span> ~exist(sprintf(<span class="string">'%s_j%d_k%d.mat'</span>,savePOA,j,k),<span class="string">'file'</span>)
0379                 <span class="keyword">if</span> abs(fluxRange(j,2) - fluxRange(j,1)) &lt; 1e-8
0380                     fluxRangeJ = fluxRange(j, 1);
0381                     NstepJK = 1;
0382                 <span class="keyword">else</span>
0383                     <span class="keyword">if</span> numel(Nstep) &gt; 1
0384                         <span class="comment">%manually supply Nstep vector (% from min to max)</span>
0385                         NstepJK = numel(Nstep);
0386                         fluxRangeJ = fluxRange(j,1) + (fluxRange(j,2) - fluxRange(j,1)) * Nstep;
0387                     <span class="keyword">else</span>
0388                         <span class="comment">%uniform step or log-scaled step</span>
0389                         NstepJK = Nstep;
0390                         <span class="keyword">if</span> strcmp(NstepScale, <span class="string">'log'</span>)
0391                             <span class="keyword">if</span> sign(fluxRange(j,2)) == sign(fluxRange(j,1))
0392                                 <span class="keyword">if</span> fluxRange(j,1) &gt; 0
0393                                     [a, b] = deal(fluxRange(j,1), fluxRange(j,2));
0394                                     fluxRangeJ = exp(log(a) + ((log(b) - log(a))/(Nstep - 1)) * (0:(Nstep - 1)));
0395                                 <span class="keyword">else</span>
0396                                     [b, a] = deal(-fluxRange(j,1), -fluxRange(j,2));
0397                                     fluxRangeJ = exp(log(a) + ((log(b) - log(a))/(Nstep - 1)) * (0:(Nstep - 1)));
0398                                     fluxRangeJ = -fluxRangeJ(end:-1:1);
0399                                 <span class="keyword">end</span>
0400                             <span class="keyword">else</span>
0401                                 <span class="comment">%Not an ideal situation. Flux ranges containing zero</span>
0402                                 <span class="comment">%should not use step size at log scale</span>
0403                                 a = [-inf, (1:(Nstep-1))/(Nstep-1)];
0404                                 fluxRangeJ = fluxRange(j,1) + (fluxRange(j,2) - fluxRange(j,1)) * 0.01 * (100 .^ a);
0405                             <span class="keyword">end</span>
0406                         <span class="keyword">else</span>
0407                             <span class="comment">%uniform step size</span>
0408                             fluxRangeJ = (fluxRange(j,1) : (fluxRange(j,2) - fluxRange(j,1)) / (Nstep - 1) : fluxRange(j,2))';
0409                         <span class="keyword">end</span>
0410                     <span class="keyword">end</span>
0411                     fluxRangeJ = fluxRangeJ(:);
0412                 <span class="keyword">end</span>
0413                 <span class="comment">%delete constraint added in the previous round if any</span>
0414                 <span class="keyword">if</span> addConstraint
0415                     LP.delRows(size(LP.Model.A,1));
0416                     addConstraint = false;
0417                 <span class="keyword">end</span>
0418                 <span class="comment">%if not a single flux, but a linear combination, add explicit constraint.</span>
0419                 <span class="keyword">if</span> nnz(objList(:,j)) &gt; 1
0420                     LP.addRows(-inf, objList(:,j)',inf, <span class="string">'POArow'</span>);
0421                     addConstraint = true;
0422                 <span class="keyword">else</span>
0423                     rxnNameId = objList(:,j) ~= 0;
0424                 <span class="keyword">end</span>
0425                 
0426                 <span class="keyword">if</span> j == k
0427                     <span class="comment">%Nothing to analyze. Just record the flux range</span>
0428                     POAtableJK = fluxRangeJ;
0429                     StatJK.cor = [1 1];
0430                     StatJK.r2 = [1 1];
0431                 <span class="keyword">else</span>
0432                     fluxPOAvalue = zeros(NstepJK, 2);
0433                     <span class="comment">%reset LP bounds</span>
0434                     LP.Model.lb = lb0;
0435                     LP.Model.ub = ub0;
0436                     <span class="keyword">for</span> p = 1:NstepJK
0437                         <span class="comment">%fix flux of the j-th reaction</span>
0438                         <span class="keyword">if</span> addConstraint
0439                             LP.Model.lhs(end) = fluxRangeJ(p) - 1e-12;
0440                             LP.Model.rhs(end) = fluxRangeJ(p) + 1e-12;
0441                         <span class="keyword">else</span>
0442                             LP.Model.lb(rxnNameId) = fluxRangeJ(p) - 1e-12;
0443                             LP.Model.ub(rxnNameId) = fluxRangeJ(p) + 1e-12;
0444                         <span class="keyword">end</span>
0445                         LP.Model.obj(:) = 0;
0446                         <span class="comment">%minimize flux of the k-th reaction</span>
0447                         LP.Model.obj = objList(:, k);
0448                         LP.Model.sense = <span class="string">'minimize'</span>;
0449                         LP.solve();
0450                         <span class="comment">%handle possible tolerance issues</span>
0451                         dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0452                         eps0 = 1e-9;
0453                         <span class="keyword">while</span> dev &gt; feasTol &amp;&amp; eps0 &lt; 1e-3 <span class="comment">%largest acceptable tolerance set to be 0.001</span>
0454                             eps0 = eps0 * 10;
0455                             <span class="keyword">if</span> addConstraint
0456                                 LP.Model.lhs(end) = fluxRangeJ(p) - eps0;
0457                                 LP.Model.rhs(end) = fluxRangeJ(p) + eps0;
0458                             <span class="keyword">else</span>
0459                                 LP.Model.lb(rxnNameId) = fluxRangeJ(p) - eps0;
0460                                 LP.Model.ub(rxnNameId) = fluxRangeJ(p) + eps0;
0461                             <span class="keyword">end</span>
0462                             LP.solve();
0463                             dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0464                         <span class="keyword">end</span>
0465                         <span class="keyword">if</span> dev &lt;= feasTol
0466                             fluxPOAvalue(p, 1) = LP.Model.obj'*LP.Solution.x;
0467                         <span class="keyword">else</span>
0468                             fluxPOAvalue(p, 1) = NaN; <span class="comment">%shoud not happen</span>
0469                         <span class="keyword">end</span>
0470                         <span class="comment">%maximize flux of the k-th reaction</span>
0471                         LP.Model.sense = <span class="string">'maximize'</span>;
0472                         LP.solve();
0473                         dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0474                         eps0 = 1e-9;
0475                         <span class="keyword">while</span> dev &gt; feasTol &amp;&amp; eps0 &lt; 1e-3
0476                             eps0 = eps0 * 10;
0477                             <span class="keyword">if</span> addConstraint
0478                                 LP.Model.lhs(end) = fluxRangeJ(p) - eps0;
0479                                 LP.Model.rhs(end) = fluxRangeJ(p) + eps0;
0480                             <span class="keyword">else</span>
0481                                 LP.Model.lb(rxnNameId) = fluxRangeJ(p) - eps0;
0482                                 LP.Model.ub(rxnNameId) = fluxRangeJ(p) + eps0;
0483                             <span class="keyword">end</span>
0484                             LP.solve();
0485                             dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0486                         <span class="keyword">end</span>
0487                         <span class="keyword">if</span> dev &lt;= feasTol
0488                             fluxPOAvalue(p, 2) = LP.Model.obj'*LP.Solution.x;
0489                         <span class="keyword">else</span>
0490                             fluxPOAvalue(p, 2) = NaN; <span class="comment">%shoud not happen</span>
0491                         <span class="keyword">end</span>
0492                         
0493                     <span class="keyword">end</span>
0494                     POAtableJK = fluxPOAvalue;
0495                     <span class="comment">%simple linear regression to check correlations</span>
0496                     notNan = ~isnan(fluxPOAvalue(:,1));
0497                     [bMin,~,~,~,statMin] = regress(fluxPOAvalue(notNan,1),<span class="keyword">...</span>
0498                         [fluxRangeJ(notNan) ones(sum(notNan),1)]);
0499                     notNan = ~isnan(fluxPOAvalue(:,2));
0500                     [bMax,~,~,~,statMax] = regress(fluxPOAvalue(notNan,2),<span class="keyword">...</span>
0501                         [fluxRangeJ(notNan) ones(sum(notNan),1)]);
0502                     StatJK.cor = [bMin(1) bMax(1)];
0503                     StatJK.r2 = [statMin(1) statMax(1)];
0504                 <span class="keyword">end</span>
0505                 <span class="keyword">if</span> verbFlag
0506                     <span class="keyword">if</span> j ~= k
0507                         strPrintj = strjoin(strtrim(cellstr(LP.Model.colname(objList(:,j)~=0,:))),<span class="string">','</span>);
0508                         strPrintk = strjoin(strtrim(cellstr(LP.Model.colname(objList(:,k)~=0,:))),<span class="string">','</span>);
0509                         fprintf(<span class="string">'%15s%15s%10.4f%10.4f%10.4f%10.4f   %04d-%02d-%02d %02d:%02d:%02.0f\n'</span>,<span class="keyword">...</span>
0510                             strPrintj, strPrintk, StatJK.cor(1), StatJK.r2(1), <span class="keyword">...</span>
0511                             StatJK.cor(2), StatJK.r2(2), clock);
0512                     <span class="keyword">end</span>
0513                 <span class="keyword">end</span>
0514                 <span class="comment">%save</span>
0515                 <span class="keyword">if</span> ~isempty(savePOA)
0516                     <a href="#_sub1" class="code" title="subfunction iSave(savePOA,POAtableJK,StatJK,GR,j0,k0)">iSave</a>(savePOA,POAtableJK,StatJK,GR,j,k);
0517                 <span class="keyword">end</span>
0518             <span class="keyword">end</span>
0519         <span class="keyword">end</span>
0520     <span class="keyword">else</span>
0521         <span class="comment">%% parallel</span>
0522         fprintf(<span class="string">'POA in parallel...\n'</span>);
0523         
0524         <span class="comment">%save and load the variables to ensure the parallel code processor can</span>
0525         <span class="comment">%recognize the variables</span>
0526         tmpSave = <span class="string">'POAtmp.mat'</span>;
0527         kTemp = 0;
0528         <span class="keyword">while</span> exist(tmpSave,<span class="string">'file'</span>)
0529             kTemp = kTemp + 1;
0530             tmpSave = [<span class="string">'POAtmp'</span> num2str(kTemp) <span class="string">'.mat'</span>];
0531         <span class="keyword">end</span>
0532         save(tmpSave, <span class="string">'symmetric'</span>,<span class="string">'verbFlag'</span>,<span class="string">'savePOA'</span>,<span class="string">'fluxRange'</span>,<span class="string">'Nstep'</span>);
0533         tmpLoad = load(tmpSave);
0534         verbFlag = tmpLoad.verbFlag;
0535         savePOA = tmpLoad.savePOA;
0536         fluxRange = tmpLoad.fluxRange;
0537         Nstep = tmpLoad.Nstep;
0538         delete(tmpSave);
0539         clear tmpLoad
0540         LPmodel = LP.Model;
0541         LPstart = LP.Start;
0542         <span class="comment">%parallelization using spmd to allow redistribution of jobs upon</span>
0543         <span class="comment">%completion of any of the workers to avoid being idle</span>
0544         numPool = gcp;
0545         numPool = numPool.NumWorkers;
0546         <span class="keyword">while</span> Npair &gt; 0
0547             <span class="comment">%mannually distribute jobs</span>
0548             remainder = mod(Npair,numPool);
0549             nJ = floor(Npair/numPool);
0550             kJ = 0;
0551             nRange = cell(numPool,1);
0552             undoneCur = Composite();
0553             <span class="comment">%Composite object is assigned as one cell/worker outside</span>
0554             <span class="comment">%spmd blocks but called as the cell content inside spmd blocks</span>
0555             <span class="keyword">for</span> kP = 1:numPool
0556                 <span class="keyword">if</span> kP &lt;= remainder
0557                     nRange{kP} = (kJ + 1) : (kJ + nJ + 1);
0558                     kJ = kJ + nJ + 1;
0559                 <span class="keyword">else</span>
0560                     nRange{kP} = (kJ + 1) : (kJ + nJ);
0561                     kJ = kJ + nJ;
0562                 <span class="keyword">end</span>
0563                 nRange{kP} = undoneId(nRange{kP});
0564                 undoneCur{kP} = undone(nRange{kP});
0565             <span class="keyword">end</span>
0566             spmd
0567                 <span class="comment">%setup local LP</span>
0568                 LPp = Cplex(<span class="string">'subproblem'</span>);
0569                 LPp.Model = LPmodel;
0570                 LPp = <a href="setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LPp, solverParam);
0571                 LPp.Start = LPstart;
0572                 addConstraint = false;
0573                 <span class="comment">%denote wether the current flag is the first to finish</span>
0574                 first = true;
0575                 <span class="keyword">for</span> jP = 1:numel(nRange{labindex}) <span class="comment">%labindex = #thread</span>
0576                     [j,k] = deal(pairList(nRange{labindex}(jP),1),pairList(nRange{labindex}(jP),2));
0577                     <span class="keyword">if</span> ~exist(sprintf(<span class="string">'%s_j%d_k%d.mat'</span>,savePOA,j,k),<span class="string">'file'</span>)
0578                         <span class="keyword">if</span> abs(fluxRange(j,2) - fluxRange(j,1)) &lt; 1e-8
0579                             fluxRangeJ = fluxRange(j, 1);
0580                             NstepJK = 1;
0581                         <span class="keyword">else</span>
0582                             <span class="keyword">if</span> numel(Nstep) &gt; 1
0583                                 <span class="comment">%mannually supplied Nstep vector (% from min to max)</span>
0584                                 NstepJK = numel(Nstep);
0585                                 fluxRangeJ = fluxRange(j,1) + (fluxRange(j,2) - fluxRange(j,1)) * Nstep;
0586                             <span class="keyword">else</span>
0587                                 <span class="comment">%uniform steps or log-scaled steps</span>
0588                                 NstepJK = Nstep;
0589                                 <span class="keyword">if</span> strcmp(NstepScale, <span class="string">'log'</span>)
0590                                     <span class="keyword">if</span> sign(fluxRange(j,2)) == sign(fluxRange(j,1))
0591                                         <span class="keyword">if</span> fluxRange(j,1) &gt; 0
0592                                             [a, b] = deal(fluxRange(j,1), fluxRange(j,2));
0593                                             fluxRangeJ = exp(log(a) + ((log(b) - log(a))/(Nstep - 1)) * (0:(Nstep - 1)));
0594                                         <span class="keyword">else</span>
0595                                             [b, a] = deal(-fluxRange(j,1), -fluxRange(j,2));
0596                                             fluxRangeJ = exp(log(a) + ((log(b) - log(a))/(Nstep - 1)) * (0:(Nstep - 1)));
0597                                             fluxRangeJ = -fluxRangeJ(end:-1:1);
0598                                         <span class="keyword">end</span>
0599                                     <span class="keyword">else</span>
0600                                         <span class="comment">%Not an ideal situation. Flux ranges containing zero</span>
0601                                         <span class="comment">%should not use step size at log scale</span>
0602                                         a = [-inf, (1:(Nstep-1))/(Nstep-1)];
0603                                         fluxRangeJ = fluxRange(j,1) + (fluxRange(j,2) - fluxRange(j,1)) * 0.01 * (100 .^ a);
0604                                     <span class="keyword">end</span>
0605                                 <span class="keyword">else</span>
0606                                     <span class="comment">%linear step size</span>
0607                                     fluxRangeJ = (fluxRange(j,1) : (fluxRange(j,2) - fluxRange(j,1)) / (Nstep - 1) : fluxRange(j,2))';
0608                                 <span class="keyword">end</span>
0609                             <span class="keyword">end</span>
0610                             fluxRangeJ = fluxRangeJ(:);
0611                         <span class="keyword">end</span>
0612                         StatJK = struct();
0613                         <span class="keyword">if</span> j == k
0614                             <span class="comment">%Nothing to analyze. Just record the flux range</span>
0615                             POAtableJK = fluxRangeJ;
0616                             StatJK.cor = [1 1];
0617                             StatJK.r2 = [1 1];
0618                         <span class="keyword">else</span>
0619                             <span class="comment">%reset LP bounds</span>
0620                             LPp.Model.lb = lb0;
0621                             LPp.Model.ub = ub0;
0622                             <span class="comment">%delete constraint added in the previous round if any</span>
0623                             <span class="keyword">if</span> addConstraint
0624                                 LPp.delRows(size(LPp.Model.A,1));
0625                                 addConstraint = false;
0626                             <span class="keyword">end</span>
0627                             <span class="comment">%if not a single flux, but a linear combination, add explicit constraint.</span>
0628                             rxnNameId = [];
0629                             <span class="keyword">if</span> nnz(objList(:,j)) &gt; 1
0630                                 LPp.addRows(-inf, objList(:,j)',inf, <span class="string">'POArow'</span>);
0631                                 addConstraint = true;
0632                             <span class="keyword">else</span>
0633                                 rxnNameId = objList(:,j) ~= 0;
0634                             <span class="keyword">end</span>
0635                             
0636                             fluxPOAvalue = zeros(NstepJK, 2);
0637                             <span class="keyword">for</span> p = 1:NstepJK
0638                                 <span class="comment">%fix flux of the j-th reaction</span>
0639                                 <span class="keyword">if</span> addConstraint
0640                                     LPp.Model.lhs(end) = fluxRangeJ(p) - 1e-12;
0641                                     LPp.Model.rhs(end) = fluxRangeJ(p) + 1e-12;
0642                                 <span class="keyword">else</span>
0643                                     LPp.Model.lb(rxnNameId) = fluxRangeJ(p) - 1e-12;
0644                                     LPp.Model.ub(rxnNameId) = fluxRangeJ(p) + 1e-12;
0645                                 <span class="keyword">end</span>
0646                                 <span class="comment">%minimize flux of the k-th reaction</span>
0647                                 LPp.Model.obj = objList(:, k);
0648                                 LPp.Model.sense = <span class="string">'minimize'</span>;
0649                                 LPp.solve();
0650                                 <span class="comment">%handle possible tolerance issues</span>
0651                                 dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LPp);
0652                                 eps0 = 1e-9;
0653                                 <span class="keyword">while</span> dev &gt; feasTol &amp;&amp; eps0 &lt; 1e-3
0654                                     eps0 = eps0 * 10;
0655                                     <span class="keyword">if</span> addConstraint
0656                                         LPp.Model.lhs(end) = fluxRangeJ(p) - eps0;
0657                                         LPp.Model.rhs(end) = fluxRangeJ(p) + eps0;
0658                                     <span class="keyword">else</span>
0659                                         LPp.Model.lb(rxnNameId) = fluxRangeJ(p) - eps0;
0660                                         LPp.Model.ub(rxnNameId) = fluxRangeJ(p) + eps0;
0661                                     <span class="keyword">end</span>
0662                                     LPp.solve();
0663                                     dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LPp);
0664                                 <span class="keyword">end</span>
0665                                 <span class="keyword">if</span> dev &lt;= feasTol
0666                                     minf = LPp.Model.obj'*LPp.Solution.x;
0667                                 <span class="keyword">else</span>
0668                                     minf = NaN; <span class="comment">%shoud not happen</span>
0669                                 <span class="keyword">end</span>
0670                                 <span class="comment">%maximize flux of the k-th reaction</span>
0671                                 LPp.Model.sense = <span class="string">'maximize'</span>;
0672                                 LPp.solve();
0673                                 <span class="comment">%handle possible tolerance issues</span>
0674                                 dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LPp);
0675                                 eps0 = 1e-9;
0676                                 <span class="keyword">while</span> dev &gt; feasTol &amp;&amp; eps0 &lt; 1e-3
0677                                     eps0 = eps0 * 10;
0678                                     <span class="keyword">if</span> addConstraint
0679                                         LPp.Model.lhs(end) = fluxRangeJ(p) - eps0;
0680                                         LPp.Model.rhs(end) = fluxRangeJ(p) + eps0;
0681                                     <span class="keyword">else</span>
0682                                         LPp.Model.lb(rxnNameId) = fluxRangeJ(p) - eps0;
0683                                         LPp.Model.ub(rxnNameId) = fluxRangeJ(p) + eps0;
0684                                     <span class="keyword">end</span>
0685                                     LPp.solve();
0686                                     dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LPp);
0687                                 <span class="keyword">end</span>
0688                                 <span class="keyword">if</span> dev &lt;= feasTol
0689                                     maxf = LPp.Model.obj'*LPp.Solution.x;
0690                                 <span class="keyword">else</span>
0691                                     maxf = NaN; <span class="comment">%shoud not happen</span>
0692                                 <span class="keyword">end</span>
0693                                 fluxPOAvalue(p,:) = [minf maxf];
0694                             <span class="keyword">end</span>
0695                             
0696                             POAtableJK = fluxPOAvalue;
0697                             <span class="comment">%simple linear regression to check correlations</span>
0698                             notNan = ~isnan(fluxPOAvalue(:,1));
0699                             [bMin,~,~,~,statMin] = regress(fluxPOAvalue(notNan,1),<span class="keyword">...</span>
0700                                 [fluxRangeJ(notNan) ones(sum(notNan),1)]);
0701                             notNan = ~isnan(fluxPOAvalue(:,2));
0702                             [bMax,~,~,~,statMax] = regress(fluxPOAvalue(notNan,2),<span class="keyword">...</span>
0703                                 [fluxRangeJ(notNan) ones(sum(notNan),1)]);
0704                             StatJK.cor = [bMin(1) bMax(1)];
0705                             StatJK.r2 = [statMin(1) statMax(1)];
0706                         <span class="keyword">end</span>
0707                         <span class="keyword">if</span> verbFlag
0708                             <span class="keyword">if</span> j ~= k
0709                                 strPrintj = strjoin(strtrim(cellstr(LPp.Model.colname(objList(:,j)~=0,:))),<span class="string">','</span>);
0710                                 strPrintk = strjoin(strtrim(cellstr(LPp.Model.colname(objList(:,k)~=0,:))),<span class="string">','</span>);
0711                                 fprintf(<span class="string">'%15s%15s%10.4f%10.4f%10.4f%10.4f   %04d-%02d-%02d %02d:%02d:%02.0f\n'</span>,<span class="keyword">...</span>
0712                                     strPrintj, strPrintk,<span class="keyword">...</span>
0713                                     StatJK.cor(1), StatJK.r2(1), <span class="keyword">...</span>
0714                                     StatJK.cor(2), StatJK.r2(2), clock);
0715                             <span class="keyword">end</span>
0716                         <span class="keyword">end</span>
0717                         <span class="keyword">if</span> ~isempty(savePOA)
0718                             <a href="#_sub1" class="code" title="subfunction iSave(savePOA,POAtableJK,StatJK,GR,j0,k0)">iSave</a>(savePOA,POAtableJK,StatJK,GR,j,k);
0719                         <span class="keyword">end</span>
0720                     <span class="keyword">end</span>
0721                     undoneCur(jP) = false;
0722                     <span class="comment">%check if any of workers has finished its loop, break the</span>
0723                     <span class="comment">%loop and redistribute if finished</span>
0724                     <span class="keyword">if</span> labProbe(<span class="string">'any'</span>,0);
0725                         first = false;
0726                         <span class="keyword">break</span>
0727                     <span class="keyword">end</span>
0728                 <span class="keyword">end</span>
0729                 <span class="keyword">if</span> first
0730                     <span class="comment">%finish of one worker, call off other workers</span>
0731                     <span class="keyword">if</span> verbFlag
0732                         fprintf(<span class="string">'Current loop finished. Stop other workers...\n'</span>);
0733                     <span class="keyword">end</span>
0734                     labSend(true,setdiff(1:numlabs,labindex),0);
0735                     <span class="keyword">if</span> verbFlag
0736                         fprintf(<span class="string">'All workers have ceased. Redistributing...\n'</span>);
0737                     <span class="keyword">end</span>
0738                 <span class="keyword">end</span>
0739                 <span class="comment">%avoid warning of missed message</span>
0740                 pause(1e-8);
0741                 <span class="keyword">while</span> labProbe(<span class="string">'any'</span>,0);
0742                     pause(1e-8);
0743                     labReceive(<span class="string">'any'</span>,0);
0744                 <span class="keyword">end</span>
0745             <span class="keyword">end</span>
0746             <span class="comment">%update undone</span>
0747             <span class="keyword">for</span> kP = 1:numPool
0748                 undone(nRange{kP}) = undoneCur{kP};
0749             <span class="keyword">end</span>
0750             undoneId = find(undone);
0751             Npair = numel(undoneId);
0752         <span class="keyword">end</span>
0753     <span class="keyword">end</span>
0754 <span class="keyword">end</span>
0755 <span class="keyword">if</span> verbFlag
0756     fprintf(<span class="string">'Finished. Save final results to %s.mat\n'</span>,savePOA);
0757 <span class="keyword">end</span>
0758 POAtable = cell(Ncheck, Ncheck);
0759 Stat = repmat(struct(<span class="string">'cor'</span>,0,<span class="string">'r2'</span>,0), Ncheck, Ncheck);
0760 <span class="keyword">for</span> jP = 1:size(pairList,1)
0761     data = load(sprintf(<span class="string">'%s_j%d_k%d.mat'</span>,savePOA,pairList(jP,1),<span class="keyword">...</span>
0762         pairList(jP,2)),<span class="string">'POAtableJK'</span>, <span class="string">'StatJK'</span>);
0763     POAtable{pairList(jP,1),pairList(jP,2)} = data.POAtableJK;
0764     Stat(pairList(jP,1),pairList(jP,2)) = data.StatJK;
0765 <span class="keyword">end</span>
0766 save(sprintf(<span class="string">'%s.mat'</span>,savePOA),<span class="string">'POAtable'</span>, <span class="string">'Stat'</span>, <span class="string">'GR'</span>, <span class="keyword">...</span>
0767     <span class="string">'fluxRange'</span>);
0768 <span class="keyword">end</span>
0769 
0770 <a name="_sub1" href="#_subfunctions" class="code">function iSave(savePOA,POAtableJK,StatJK,GR,j0,k0)</a>
0771 save(sprintf(<span class="string">'%s_j%d_k%d.mat'</span>,savePOA,j0,k0),<span class="string">'POAtableJK'</span>, <span class="string">'StatJK'</span>, <span class="string">'GR'</span>,<span class="string">'j0'</span>,<span class="string">'k0'</span>);
0772 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sat 06-May-2017 09:55:30 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>