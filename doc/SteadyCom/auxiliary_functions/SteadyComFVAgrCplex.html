<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SteadyComFVAgrCplex</title>
  <meta name="keywords" content="SteadyComFVAgrCplex">
  <meta name="description" content="Flux variability analysis for community model at community steady-state at a given growth rate.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html SteadyCom --><!-- menu.html auxiliary_functions -->
<h1>SteadyComFVAgrCplex
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Flux variability analysis for community model at community steady-state at a given growth rate.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [minFlux,maxFlux,minFD,maxFD,LP,GR] = SteadyComFVAgrCplex(modelCom,options,solverParam,LP) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Flux variability analysis for community model at community steady-state at a given growth rate. 
The function is capable of saving intermediate results and continuing from previous results 
if the file path is given in options.saveFVA. It also allows switch from single thread to parallel 
computation from intermediate results (but not the reverse).

[minFlux,maxFlux,minFD,maxFD,LP,GR] = SteadyComFVAgrCplex(modelCom,options,solverParam,LP)

INPUT
 modelCom        a community COBRA model structure with the following extra fields:
 (the following fields are required - others can be supplied)
   S            Stoichiometric matrix
   b            Right hand side
   c            Objective coefficients
   lb           Lower bounds
   ub           Upper bounds
 (at least one of the below two is needed)
   infoCom      structure containing community reaction info 
                (returned along with the community model created with createCommModel)
   indCom       the index structure corresponding to infoCom

 options (optional) option structure with the following fields:
   GR              The growth rate at which FVA is performed. If not
                     given, find the maximum growth rate by SteadyComCplex.m
   optBMpercent    Only consider solutions that yield at least a certain
                     percentage of the optimal biomass (Default = 99.99)
   rxnNameList     List of reactions (IDs or .rxns) for which FVA is performed.
                     Use a (N_rxns + N_organism) x K matrix for FVA of K
                     linear combinations of fluxes and/or abundances
                     (Default = biomass reaction of each species)
   rxnFluxList     List of reactions (IDs or .rxns) whose fluxes are also returned
                     (Default = biomass reaction of each species)
  (the two parameters below are usually determined by solving the problem
      during the program. Provide them only if you want to constrain the
      total biomass to a particular value)
   BMmaxLB         lower bound for the total biomass (default 1)
   BMmaxUB         upper bound for the total biomass
  (other parameters)
   saveFVA         If non-empty, become the filename to save the FVA results
                   (default empty, not saving)
   threads         &gt; 1 for explicitly stating the no. of threads used,
                   0 or -1 for using all available threads. Default 1.
   verbFlag        Verbose output. 1 to have waitbar, &gt;1 to have stepwise output
                   (default 3)
   loadModel       String of filename to be loaded. If non-empty, load the 
                   cplex model ('loadModel.mps'), basis ('loadModel.bas') 
                   and parameters ('loadModel.prm').
  May add also other parameters in SteadyComCplex for calculating the maximum growth rate.

 solverParam       Cplex parameter structure. E.g., struct('simplex',struct('tolerances',struct('feasibility',1e-8)))
 LP                Cplex LP object from, e.g., calling FVAComCplex

OUTPUT
 minFlux       Minimum flux for each reaction
 maxFlux       Maximum flux for each reaction

OPTIONAL OUTPUT
 minFD         #rxnFluxList x #rxnNameList matrix containing the fluxes in
               options.rxnFluxList corresponding to minimizing each reaction in
               options.rxnNameList
 maxFD         #rxnFluxList x #rxnNameList matrix containing the fluxes in
               options.rxnFluxList corresponding to maximizing each reaction in
               options.rxnNameList
 LP            Cplex LP object
 GR            the growth rate at which FVA is performed</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../SteadyCom/SteadyComCplex.html" class="code" title="function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP)">SteadyComCplex</a>	Find the maximum community growth rate at community steady-state using SteadyCom</li><li><a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>	Check the feasibility of a solution given a COBRA model structure or a CPLEX dynamic object and a solution</li><li><a href="getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>	get the required default parameters</li><li><a href="infoCom2indCom.html" class="code" title="function indCom = infoCom2indCom(modelCom,infoCom,revFlag,spAbbr,spName)">infoCom2indCom</a>	Transform between community reaction IDs and reaction names</li><li><a href="setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>	Set the parameters of the CPLEX object according to the structure solverParam</li><li><a href="updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>	Create and update the SteadyCom LP model in CPLEX format.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../SteadyCom/SteadyComFVACplex.html" class="code" title="function [minFlux,maxFlux,minFD,maxFD, GRvector, result,LP] = SteadyComFVACplex(modelCom,options,solverParam)">SteadyComFVACplex</a>	Flux variability analysis for community model at community steady-state for a range of growth rates.</li><li><a href="SteadyComPOAgrCplex.html" class="code" title="function [POAtable, fluxRange, Stat, pairList] = SteadyComPOAgrCplex(modelCom,options,solverParam,LP)">SteadyComPOAgrCplex</a>	Pairwise POA for community model at community steady-state at a given growth rate</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function parSave(minFluxP,maxFluxP,minFDP,maxFDP,i0,jP,saveFVA)</a></li><li><a href="#_sub2" class="code">function [minFluxP,maxFluxP,minFDP,maxFDP,i0] = parLoad(jP,saveFVA)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [minFlux,maxFlux,minFD,maxFD,LP,GR] = SteadyComFVAgrCplex(modelCom,options,solverParam,LP)</a>
0002 <span class="comment">%Flux variability analysis for community model at community steady-state at a given growth rate.</span>
0003 <span class="comment">%The function is capable of saving intermediate results and continuing from previous results</span>
0004 <span class="comment">%if the file path is given in options.saveFVA. It also allows switch from single thread to parallel</span>
0005 <span class="comment">%computation from intermediate results (but not the reverse).</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%[minFlux,maxFlux,minFD,maxFD,LP,GR] = SteadyComFVAgrCplex(modelCom,options,solverParam,LP)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%INPUT</span>
0010 <span class="comment">% modelCom        a community COBRA model structure with the following extra fields:</span>
0011 <span class="comment">% (the following fields are required - others can be supplied)</span>
0012 <span class="comment">%   S            Stoichiometric matrix</span>
0013 <span class="comment">%   b            Right hand side</span>
0014 <span class="comment">%   c            Objective coefficients</span>
0015 <span class="comment">%   lb           Lower bounds</span>
0016 <span class="comment">%   ub           Upper bounds</span>
0017 <span class="comment">% (at least one of the below two is needed)</span>
0018 <span class="comment">%   infoCom      structure containing community reaction info</span>
0019 <span class="comment">%                (returned along with the community model created with createCommModel)</span>
0020 <span class="comment">%   indCom       the index structure corresponding to infoCom</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% options (optional) option structure with the following fields:</span>
0023 <span class="comment">%   GR              The growth rate at which FVA is performed. If not</span>
0024 <span class="comment">%                     given, find the maximum growth rate by SteadyComCplex.m</span>
0025 <span class="comment">%   optBMpercent    Only consider solutions that yield at least a certain</span>
0026 <span class="comment">%                     percentage of the optimal biomass (Default = 99.99)</span>
0027 <span class="comment">%   rxnNameList     List of reactions (IDs or .rxns) for which FVA is performed.</span>
0028 <span class="comment">%                     Use a (N_rxns + N_organism) x K matrix for FVA of K</span>
0029 <span class="comment">%                     linear combinations of fluxes and/or abundances</span>
0030 <span class="comment">%                     (Default = biomass reaction of each species)</span>
0031 <span class="comment">%   rxnFluxList     List of reactions (IDs or .rxns) whose fluxes are also returned</span>
0032 <span class="comment">%                     (Default = biomass reaction of each species)</span>
0033 <span class="comment">%  (the two parameters below are usually determined by solving the problem</span>
0034 <span class="comment">%      during the program. Provide them only if you want to constrain the</span>
0035 <span class="comment">%      total biomass to a particular value)</span>
0036 <span class="comment">%   BMmaxLB         lower bound for the total biomass (default 1)</span>
0037 <span class="comment">%   BMmaxUB         upper bound for the total biomass</span>
0038 <span class="comment">%  (other parameters)</span>
0039 <span class="comment">%   saveFVA         If non-empty, become the filename to save the FVA results</span>
0040 <span class="comment">%                   (default empty, not saving)</span>
0041 <span class="comment">%   threads         &gt; 1 for explicitly stating the no. of threads used,</span>
0042 <span class="comment">%                   0 or -1 for using all available threads. Default 1.</span>
0043 <span class="comment">%   verbFlag        Verbose output. 1 to have waitbar, &gt;1 to have stepwise output</span>
0044 <span class="comment">%                   (default 3)</span>
0045 <span class="comment">%   loadModel       String of filename to be loaded. If non-empty, load the</span>
0046 <span class="comment">%                   cplex model ('loadModel.mps'), basis ('loadModel.bas')</span>
0047 <span class="comment">%                   and parameters ('loadModel.prm').</span>
0048 <span class="comment">%  May add also other parameters in SteadyComCplex for calculating the maximum growth rate.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% solverParam       Cplex parameter structure. E.g., struct('simplex',struct('tolerances',struct('feasibility',1e-8)))</span>
0051 <span class="comment">% LP                Cplex LP object from, e.g., calling FVAComCplex</span>
0052 <span class="comment">%</span>
0053 <span class="comment">%OUTPUT</span>
0054 <span class="comment">% minFlux       Minimum flux for each reaction</span>
0055 <span class="comment">% maxFlux       Maximum flux for each reaction</span>
0056 <span class="comment">%</span>
0057 <span class="comment">%OPTIONAL OUTPUT</span>
0058 <span class="comment">% minFD         #rxnFluxList x #rxnNameList matrix containing the fluxes in</span>
0059 <span class="comment">%               options.rxnFluxList corresponding to minimizing each reaction in</span>
0060 <span class="comment">%               options.rxnNameList</span>
0061 <span class="comment">% maxFD         #rxnFluxList x #rxnNameList matrix containing the fluxes in</span>
0062 <span class="comment">%               options.rxnFluxList corresponding to maximizing each reaction in</span>
0063 <span class="comment">%               options.rxnNameList</span>
0064 <span class="comment">% LP            Cplex LP object</span>
0065 <span class="comment">% GR            the growth rate at which FVA is performed</span>
0066 
0067 <span class="comment">%% Initialization</span>
0068 <span class="comment">%check required fields for community model</span>
0069 <span class="keyword">if</span> ~isfield(modelCom,<span class="string">'indCom'</span>)
0070     <span class="keyword">if</span> ~isfield(modelCom,<span class="string">'infoCom'</span>) || ~isstruct(modelCom.infoCom) || <span class="keyword">...</span>
0071             ~all(isfield(modelCom.infoCom,{<span class="string">'spBm'</span>,<span class="string">'EXcom'</span>,<span class="string">'EXsp'</span>,<span class="string">'spAbbr'</span>,<span class="string">'rxnSps'</span>,<span class="string">'metSps'</span>}))
0072         error(<span class="string">'infoCom must be provided for calculating the max. community growth rate.\n'</span>);
0073     <span class="keyword">end</span>
0074     <span class="comment">%get useful reaction indices</span>
0075     modelCom.indCom = <a href="infoCom2indCom.html" class="code" title="function indCom = infoCom2indCom(modelCom,infoCom,revFlag,spAbbr,spName)">infoCom2indCom</a>(modelCom);
0076 <span class="keyword">end</span>
0077 
0078 <span class="comment">%get paramters</span>
0079 <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>)
0080     options = struct();
0081 <span class="keyword">end</span>
0082 <span class="keyword">if</span> ~exist(<span class="string">'solverParam'</span>, <span class="string">'var'</span>) || isempty(solverParam)
0083     <span class="comment">%default Cplex parameters</span>
0084     solverParam = <a href="getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>(<span class="string">'CplexParam'</span>);
0085 <span class="keyword">end</span>
0086 param2get = {<span class="string">'GR'</span>, <span class="string">'optBMpercent'</span>, <span class="string">'rxnNameList'</span>, <span class="string">'rxnFluxList'</span>, <span class="keyword">...</span>
0087              <span class="string">'GRfx'</span>, <span class="string">'BMmaxLB'</span>,<span class="string">'BMmaxUB'</span>,<span class="keyword">...</span>
0088              <span class="string">'threads'</span>,<span class="string">'verbFlag'</span>,<span class="string">'loadModel'</span>,<span class="string">'saveFVA'</span>};
0089 eval(sprintf(<span class="string">'[%s] = getCobraComParams(param2get, options, modelCom);'</span>, <span class="keyword">...</span>
0090             strjoin(param2get, <span class="string">','</span>)<span class="keyword">...</span>
0091             )<span class="keyword">...</span>
0092     );
0093 [feasTol, ~] = getCobraSolverParams(<span class="string">'LP'</span>,{<span class="string">'feasTol'</span>; <span class="string">'optTol'</span>}, solverParam);
0094 <span class="keyword">if</span> isfield(solverParam,<span class="string">'simplex'</span>) &amp;&amp; isfield(solverParam.simplex, <span class="string">'tolerances'</span>)<span class="keyword">...</span>
0095         &amp;&amp; isfield(solverParam.simplex.tolerances,<span class="string">'feasibility'</span>)
0096     <span class="comment">%override the feasTol in CobraSolverParam if given in solverParam</span>
0097     feasTol = solverParam.simplex.tolerances.feasibility;
0098 <span class="keyword">else</span>
0099     <span class="comment">%otherwise use that in the solver</span>
0100     solverParam.simplex.tolerances.feasibility = feasTol;
0101 <span class="keyword">end</span>
0102 
0103 [m, n] = size(modelCom.S);
0104 nRxnSp = sum(modelCom.indCom.rxnSps &gt; 0); <span class="comment">%number of species-specific rxns</span>
0105 nSp = numel(modelCom.indCom.spBm); <span class="comment">%number of species</span>
0106 
0107 <span class="keyword">if</span> (~isfield(modelCom,<span class="string">'b'</span>))
0108     modelCom.b = zeros(size(modelCom.S,1),1);
0109 <span class="keyword">end</span>
0110 
0111 <span class="comment">%% setup LP structure</span>
0112 checkBMrow = false;
0113 <span class="keyword">if</span> isempty(GR)
0114     <span class="comment">%if max growth rate not given, find it and get the LP problem</span>
0115     options2 = options;
0116     options2.minNorm = false;
0117     [~, result,LP] = <a href="../../SteadyCom/SteadyComCplex.html" class="code" title="function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP)">SteadyComCplex</a>(modelCom, options2,solverParam);
0118     GR = result.GRmax;
0119     idRow = size(LP.Model.A,1);
0120     addRow = false;
0121 <span class="keyword">elseif</span> nargin &lt; 4
0122     <span class="keyword">if</span> ~isempty(loadModel)
0123         <span class="comment">% load solution if given and growth rate is known</span>
0124         LP = Cplex(<span class="string">'fva'</span>);
0125         LP.readModel([loadModel <span class="string">'.mps'</span>]);
0126         LP.readBasis([loadModel <span class="string">'.bas'</span>]);
0127         LP.readParam([loadModel <span class="string">'.prm'</span>]);
0128         fprintf(<span class="string">'Load model ''%s'' successfully.\n'</span>, loadModel);
0129         checkBMrow = true;
0130     <span class="keyword">else</span>
0131         <span class="comment">%get LP using SteadyComCplex if only growth rate is given</span>
0132         options2 = options;
0133         options2.LPonly = true;
0134         [~, ~, LP] = <a href="../../SteadyCom/SteadyComCplex.html" class="code" title="function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP)">SteadyComCplex</a>(modelCom, options2, solverParam);
0135         <span class="comment">%no constraint on total biomass using LPonly option</span>
0136         addRow = true;
0137     <span class="keyword">end</span>
0138 <span class="keyword">else</span>
0139     <span class="comment">%GR given as input and LP is supplied, expected when called by fluxVarComCplex</span>
0140     checkBMrow = true;
0141 <span class="keyword">end</span>
0142 <span class="comment">%Check if a row constraining the sum of biomass exists</span>
0143 <span class="keyword">if</span> checkBMrow
0144     <span class="keyword">if</span> size(LP.Model.A,1) &gt; m + 2*nRxnSp + nSp
0145         [ynRow,idRow] = ismember(sparse(ones(nSp,1),n+1:n+nSp,ones(nSp,1),1,n+nSp),<span class="keyword">...</span>
0146             LP.Model.A(m+2*nRxnSp+nSp+1:<span class="keyword">end</span>,1:n+nSp),<span class="string">'rows'</span>);
0147         <span class="keyword">if</span> ynRow
0148             idRow = m + 2*nRxnSp + nSp + idRow;
0149         <span class="keyword">end</span>
0150         addRow = ~ynRow;
0151     <span class="keyword">else</span>
0152         addRow = true;
0153     <span class="keyword">end</span>
0154 <span class="keyword">end</span>
0155 <span class="comment">%add a row for constraining the sum of biomass if not exist</span>
0156 <span class="keyword">if</span> addRow
0157     <span class="comment">%using default BMmaxLB and BMmaxUB if not given in options</span>
0158     LP.addRows(BMmaxLB * optBMpercent / 100, <span class="keyword">...</span>
0159         sparse(ones(1, nSp), n + 1: n + nSp, ones(1, nSp), 1, size(LP.Model.A,2)),<span class="keyword">...</span>
0160         BMmaxUB, <span class="string">'UnityBiomass'</span>);
0161     idRow = size(LP.Model.A,1);
0162 <span class="keyword">else</span>
0163     <span class="comment">%using BMmaxLB and BMmaxUB stored in the LP if not given in options</span>
0164     <span class="keyword">if</span> ~isfield(options,<span class="string">'BMmaxLB'</span>) <span class="comment">%take from LP if not supplied</span>
0165         BMmaxLB = LP.Model.lhs(idRow);
0166     <span class="keyword">end</span>
0167     <span class="keyword">if</span> ~isfield(options,<span class="string">'BMmaxUB'</span>) <span class="comment">%take from LP if not supplied</span>
0168         BMmaxUB = LP.Model.rhs(idRow);
0169     <span class="keyword">end</span>
0170     LP.Model.lhs(idRow) = BMmaxLB * optBMpercent / 100;
0171     <span class="comment">%not allow the max. biomass to exceed the one at max growth rate,</span>
0172     <span class="comment">%can happen if optBMpercent &lt; 100. May dismiss this constraint or</span>
0173     <span class="comment">%manually supply BMmaxUB in the options if sum of biomass should be variable</span>
0174     LP.Model.rhs(idRow) = BMmaxUB;
0175 <span class="keyword">end</span>
0176 <span class="comment">%set Cplex parameters</span>
0177 LP = <a href="setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LP, solverParam);
0178 nVar = size(LP.Model.A,2);
0179 
0180 BMmax0 = LP.Model.lhs(idRow);
0181 <span class="comment">%update the LP to ensure the current growth rate is constrained</span>
0182 LP.Model.A = <a href="updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, GR, GRfx, [], LP.Model.A, []);
0183 LP.Model.sense = <span class="string">'minimize'</span>;
0184 LP.Model.obj(:) = 0;
0185 LP.solve();
0186 <span class="comment">%check and adjust for feasibility</span>
0187 dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0188 kBMadjust = 0;
0189 <span class="keyword">while</span> (~isfield(LP.Solution, <span class="string">'x'</span>) || dev &gt; feasTol) &amp;&amp; kBMadjust &lt; 10
0190     kBMadjust = kBMadjust + 1;
0191     LP.Model.lhs(end) = BMmax0 * (1 - feasTol/(11 - kBMadjust));
0192     LP.solve();
0193     dev = <a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0194     <span class="keyword">if</span> verbFlag
0195         fprintf(<span class="string">'BMmax adjusment: %d\n'</span>,kBMadjust);
0196     <span class="keyword">end</span>
0197 <span class="keyword">end</span>
0198 
0199 <span class="keyword">if</span> (~isfield(LP.Solution, <span class="string">'x'</span>) || dev &gt; feasTol)
0200     error(<span class="string">'Model not feasible.'</span>)
0201 <span class="keyword">end</span>
0202 BMmax0 = LP.Model.lhs(idRow);
0203 
0204 <span class="comment">%% handle variables for FVA (objective matrix) and fluxes to return</span>
0205 <span class="comment">%fluxes to return</span>
0206 <span class="keyword">if</span> isnumeric(rxnFluxList)
0207     rxnFluxId = rxnFluxList;
0208 <span class="keyword">elseif</span> iscell(rxnFluxList) || ischar(rxnFluxList)
0209     rxnFluxId = findRxnIDs(modelCom,rxnFluxList);
0210     <span class="keyword">if</span> any(rxnFluxId) == 0
0211         error(<span class="string">'Invalid names in rxnFluxList.'</span>);
0212     <span class="keyword">end</span>
0213 <span class="keyword">end</span>
0214 
0215 <span class="comment">%objective matrix</span>
0216 <span class="keyword">if</span> ischar(rxnNameList)
0217     <span class="comment">%if input is a string, make it a cell</span>
0218     rxnNameList = {rxnNameList};
0219 <span class="keyword">end</span>
0220 <span class="keyword">if</span> isnumeric(rxnNameList)
0221     <span class="comment">%if input is numeric</span>
0222     <span class="keyword">if</span> size(rxnNameList,1) &gt;= n &amp;&amp; size(rxnNameList,1) &lt;= nVar
0223         <span class="comment">%it is a matrix of objective vectors</span>
0224         objList = [sparse(rxnNameList); sparse(nVar - size(rxnNameList,1), size(rxnNameList,2))];
0225     <span class="keyword">elseif</span> size(rxnNameList,1) == 1 || size(rxnNameList,2) == 1 
0226         <span class="comment">%reaction index</span>
0227         objList = sparse(rxnNameList, 1:numel(rxnNameList), ones(numel(rxnNameList),1),<span class="keyword">...</span>
0228             nVar, max(size(rxnNameList)));
0229     <span class="keyword">else</span>
0230         error(<span class="string">'Invalid numerical input of rxnNameList.'</span>);
0231     <span class="keyword">end</span>
0232 <span class="keyword">elseif</span> iscell(rxnNameList)
0233     <span class="comment">%handle cell input</span>
0234     objList = sparse(nVar, numel(rxnNameList));
0235     <span class="keyword">for</span> jRxnName = 1:numel(rxnNameList)
0236         <span class="comment">%each rxnNameList{jRxnName} can be a cell array of reactions</span>
0237         <span class="comment">%treat it as unweighted sum of the reactions</span>
0238         rJ = findRxnIDs(modelCom,rxnNameList{jRxnName});
0239         <span class="keyword">if</span> ~all(rJ)
0240             error(<span class="string">'Invalid names in rxnNameList'</span>);
0241         <span class="keyword">end</span>
0242         objList(rJ,jRxnName) = 1;
0243     <span class="keyword">end</span>
0244 <span class="keyword">else</span>
0245     error(<span class="string">'Invalid input of rxnNameList'</span>);
0246 <span class="keyword">end</span>
0247 
0248 <span class="comment">%parallel computation</span>
0249 p = gcp(<span class="string">'nocreate'</span>);
0250 <span class="keyword">if</span> isempty(p)
0251     <span class="keyword">if</span> threads &gt; 1
0252         <span class="comment">%given explicit no. of threads</span>
0253         parpool(ceil(threads));
0254     <span class="keyword">elseif</span> threads ~= 1
0255         <span class="comment">%default max no. of threads (input 0 or -1 etc)</span>
0256         parpool;
0257     <span class="keyword">end</span>
0258 <span class="keyword">end</span>
0259 <span class="keyword">if</span> ~isempty(saveFVA)
0260     directory = strsplit(saveFVA,filesep);
0261     <span class="keyword">if</span> numel(directory) &gt; 1
0262         <span class="comment">%not saving in the current directory. Check existence</span>
0263         directory = strjoin(directory(1:end-1),filesep);
0264         <span class="keyword">if</span> ~exist(directory,<span class="string">'dir'</span>)
0265             mkdir(directory);
0266         <span class="keyword">end</span>
0267     <span class="keyword">end</span>
0268 <span class="keyword">end</span>
0269 <span class="keyword">if</span> verbFlag
0270     fprintf(<span class="string">'\nFVA for %d sets of fluxes/biomass at growth rate %.6f :\n'</span>,<span class="keyword">...</span>
0271         size(objList,2), GR);
0272 <span class="keyword">end</span>
0273 <span class="comment">%% main loop of FVA</span>
0274 <span class="keyword">if</span> threads == 1 
0275     <span class="comment">% single-thread FVA</span>
0276     <span class="keyword">if</span> (verbFlag == 1)  
0277         h = waitbar(0,<span class="string">'Flux variability analysis in progress ...'</span>);
0278     <span class="keyword">end</span>
0279     <span class="keyword">if</span> (verbFlag &gt; 1)
0280         fprintf(<span class="string">'%4s\t%4s\t%10s\t%9s\t%9s\n'</span>,<span class="string">'No'</span>,<span class="string">'%'</span>,<span class="string">'Name'</span>,<span class="string">'Min'</span>,<span class="string">'Max'</span>);
0281     <span class="keyword">end</span>
0282 
0283     m = 0;
0284     maxFlux = zeros(size(objList,2), 1);
0285     minFlux = zeros(size(objList,2), 1);
0286     [minFD, maxFD] = deal(sparse(numel(rxnFluxId), size(objList,2)));
0287     i0 = 0;
0288     <span class="keyword">if</span> ~isempty(saveFVA)
0289         <span class="comment">%save the master model</span>
0290         LPmodel = LP.Model;
0291         LPstart = LP.Start;
0292         optionsFVA = options;
0293         save([saveFVA <span class="string">'_model.mat'</span>], <span class="string">'LPmodel'</span>,<span class="string">'LPstart'</span>,<span class="string">'optionsFVA'</span>);
0294         clear LPmodel LPstart optionsFVA
0295         <span class="comment">%continue from previous saved file</span>
0296         <span class="keyword">if</span> ~isempty(saveFVA)
0297             <span class="keyword">if</span> exist([saveFVA <span class="string">'.mat'</span>], <span class="string">'file'</span>)
0298                 load([saveFVA <span class="string">'.mat'</span>],<span class="string">'i0'</span>,<span class="string">'minFlux'</span>,<span class="string">'maxFlux'</span>,<span class="string">'minFD'</span>,<span class="string">'maxFD'</span>);
0299                 <span class="keyword">if</span> i0 == size(objList,2)
0300                     fprintf(<span class="string">'FVA was already finished previously and saved in %s.mat.\n'</span>, saveFVA);
0301                     <span class="keyword">return</span>
0302                 <span class="keyword">else</span>
0303                     fprintf(<span class="string">'Continue FVA from i = %d.\n'</span>, i0);
0304                 <span class="keyword">end</span>
0305             <span class="keyword">end</span>
0306         <span class="keyword">end</span>
0307     <span class="keyword">end</span>
0308     <span class="keyword">for</span> i = (i0 + 1):size(objList,2)
0309         <span class="keyword">if</span> (verbFlag == 1)
0310             fprintf(<span class="string">'iteration %d.  skipped %d\n'</span>, i, round(m));
0311         <span class="keyword">end</span>
0312         <span class="comment">%maximize</span>
0313         LP.Model.obj = -full(objList(:,i)); 
0314         LP.solve();
0315         <span class="keyword">while</span> ~isprop(LP, <span class="string">'Solution'</span>)
0316             <span class="keyword">try</span>
0317                 LP.solve();
0318             <span class="keyword">catch</span>
0319                 <span class="comment">%should not happen</span>
0320                 fprintf(<span class="string">'Error in solving!'</span>)
0321             <span class="keyword">end</span>
0322         <span class="keyword">end</span>
0323         <span class="comment">%Infeasibility can occur occasionally. Keep trying to relax the maximum biomass</span>
0324         eps0 = 1e-8;
0325         <span class="keyword">while</span> ~(<a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP) &lt;= feasTol) &amp;&amp; eps0 * 10 &lt;= 1e-3 <span class="comment">%LP.Solution.status ~= 1</span>
0326             eps0 = eps0 * 10;
0327             LP.Model.lhs(idRow) = BMmax0 * (1 - eps0);
0328             LP.solve();
0329         <span class="keyword">end</span>
0330         <span class="keyword">if</span> ~(<a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP) &lt;= feasTol)
0331             <span class="comment">%infeasible (suggests numerical issues)</span>
0332             maxFlux(i) = NaN;
0333             maxFD(:,i) = NaN;
0334         <span class="keyword">else</span>
0335             <span class="comment">%LP.Solution.fval can sometimes return NaN even if a solution is found</span>
0336             maxFlux(i) = -LP.Model.obj' * LP.Solution.x;
0337             maxFD(:,i) = LP.Solution.x(rxnFluxId);
0338         <span class="keyword">end</span>
0339         <span class="comment">%restore the original BMmax0</span>
0340         LP.Model.lhs(idRow) = BMmax0;
0341         
0342         <span class="comment">%minimize</span>
0343         LP.Model.obj = full(objList(:,i));
0344         LP.solve();
0345         <span class="keyword">while</span> ~isprop(LP, <span class="string">'Solution'</span>)
0346             <span class="keyword">try</span>
0347                 LP.solve();
0348             <span class="keyword">catch</span>
0349                 <span class="comment">%should not happen</span>
0350                 fprintf(<span class="string">'Error in solving!'</span>)
0351             <span class="keyword">end</span>
0352         <span class="keyword">end</span>
0353         <span class="comment">%Infeasibility can occur occasionally. Keep trying to relax the maximum biomass</span>
0354         eps0 = 1e-8;
0355         <span class="keyword">while</span> ~(<a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP) &lt;= feasTol) &amp;&amp; eps0 * 10 &lt;= 1e-3 <span class="comment">%LP.Solution.status ~= 1</span>
0356             eps0 = eps0 * 10;
0357             LP.Model.lhs(idRow) = BMmax0 * (1 - eps0);
0358             LP.solve();
0359         <span class="keyword">end</span>
0360         <span class="keyword">if</span> ~(<a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP) &lt;= feasTol)
0361             minFlux(i) = NaN;
0362             minFD(:,i) = NaN;
0363         <span class="keyword">else</span>
0364             minFlux(i) = LP.Model.obj' * LP.Solution.x;
0365             minFD(:,i) = LP.Solution.x(rxnFluxId);
0366         <span class="keyword">end</span>
0367         LP.Model.lhs(idRow) = BMmax0;
0368         
0369         <span class="keyword">if</span> (verbFlag == 1)
0370             waitbar(i/length(rxnNameList),h);
0371         <span class="keyword">end</span>
0372         <span class="keyword">if</span> (verbFlag &gt; 1)
0373             rxnNameDisp = strjoin(cellstr(LP.Model.colname(objList(:,i)~=0,:)),<span class="string">' + '</span>);
0374             fprintf(<span class="string">'%4d\t%4.0f\t%10s\t%9.6f\t%9.6f\n'</span>,i,100*i/size(objList,2),rxnNameDisp,minFlux(i),maxFlux(i));
0375         <span class="keyword">end</span>
0376         <span class="keyword">if</span> mod(i, floor(size(objList,2)/50)) == 0 
0377             <span class="keyword">if</span> ~isempty(saveFVA)
0378                 <span class="comment">%save intermediate results</span>
0379                 i0 = i;
0380                 save([saveFVA <span class="string">'.mat'</span>],<span class="keyword">...</span>
0381                     <span class="string">'i0'</span>,<span class="string">'minFlux'</span>,<span class="string">'maxFlux'</span>,<span class="string">'minFD'</span>,<span class="string">'maxFD'</span>)
0382             <span class="keyword">end</span>
0383         <span class="keyword">end</span>
0384     <span class="keyword">end</span>
0385     <span class="keyword">if</span> ~isempty(saveFVA)
0386         <span class="comment">%save final results</span>
0387         i0 = i;
0388         save([saveFVA <span class="string">'.mat'</span>],<span class="keyword">...</span>
0389             <span class="string">'i0'</span>,<span class="string">'minFlux'</span>,<span class="string">'maxFlux'</span>,<span class="string">'minFD'</span>,<span class="string">'maxFD'</span>)
0390     <span class="keyword">end</span>
0391     <span class="keyword">if</span> (verbFlag == 1)
0392         <span class="keyword">if</span> ( regexp( version, <span class="string">'R20'</span>) )
0393             close(h);
0394         <span class="keyword">end</span>
0395     <span class="keyword">end</span>
0396 <span class="keyword">else</span>
0397     <span class="comment">%% parallel FVA</span>
0398     i0P = 0;
0399     <span class="keyword">if</span> ~isempty(saveFVA)
0400         <span class="comment">%check if previous results from single-thread computation exist</span>
0401         <span class="keyword">if</span> exist([saveFVA <span class="string">'.mat'</span>], <span class="string">'file'</span>)
0402             load([saveFVA <span class="string">'.mat'</span>],<span class="string">'i0'</span>);
0403             i0P = i0;
0404             clear i0
0405             <span class="keyword">if</span> i0P == size(objList,2)
0406                 fprintf(<span class="string">'FVA was already finished previously and saved in %s.mat.\n'</span>, saveFVA);
0407                 load([saveFVA <span class="string">'.mat'</span>],<span class="string">'minFlux'</span>,<span class="string">'maxFlux'</span>,<span class="string">'minFD'</span>,<span class="string">'maxFD'</span>);
0408                 <span class="keyword">return</span>
0409             <span class="keyword">else</span>
0410                 fprintf(<span class="string">'Continue FVA from i = %d.\n'</span>, i0P);
0411             <span class="keyword">end</span>
0412         <span class="keyword">end</span>
0413     <span class="keyword">end</span>
0414     
0415     p = gcp;
0416     numPool = p.NumWorkers;
0417     <span class="comment">%assign reactions to each thread, from reaction i0P to size(objList,2)</span>
0418     rxnRange = cell(numPool,1);
0419     remainder = mod(size(objList,2)-i0P,numPool);
0420     kRxnDist = i0P;
0421     <span class="keyword">for</span> jP = 1:numPool
0422         <span class="keyword">if</span> jP &lt;= remainder
0423             rxnRange{jP} = (kRxnDist + 1):(kRxnDist + floor((size(objList,2)-i0P) / numPool) + 1);
0424         <span class="keyword">else</span>
0425             rxnRange{jP} = (kRxnDist + 1):(kRxnDist + floor((size(objList,2)-i0P) / numPool));
0426         <span class="keyword">end</span>
0427         kRxnDist = kRxnDist + numel(rxnRange{jP});
0428     <span class="keyword">end</span>
0429     LPmodel = LP.Model;
0430     LPstart = LP.Start;
0431     <span class="keyword">if</span> ~isempty(saveFVA)
0432         <span class="comment">%save the master model</span>
0433         optionsFVA = options;
0434         save([saveFVA <span class="string">'_model.mat'</span>], <span class="string">'LPmodel'</span>,<span class="string">'LPstart'</span>,<span class="string">'optionsFVA'</span>,<span class="string">'rxnRange'</span>,<span class="string">'numPool'</span>);
0435     <span class="keyword">end</span>
0436     
0437     [maxFluxCell, minFluxCell, minFDCell, maxFDCell] = deal(cell(numPool,1));
0438     fprintf(<span class="string">'%s\n'</span>,saveFVA);
0439     <span class="comment">%for technical reasons, declare the variables for Matlab</span>
0440     save(<span class="string">'FVAparallelTmpVar.mat'</span>,<span class="string">'saveFVA'</span>,<span class="string">'verbFlag'</span>);
0441     data = load(<span class="string">'FVAparallelTmpVar.mat'</span>);
0442     saveFVA = data.saveFVA;
0443     verbFlag = data.verbFlag;
0444     parfor jP = 1:numPool
0445         LPp = Cplex(<span class="string">'subproblem'</span>);
0446         LPp.Model = LPmodel;
0447         LPp = <a href="setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LPp, solverParam);
0448         LPp.Start = LPstart;
0449         maxFluxP = zeros(numel(rxnRange{jP}), 1);
0450         minFluxP = zeros(numel(rxnRange{jP}), 1);
0451         [minFDP, maxFDP] = deal(sparse(numel(rxnFluxId), numel(rxnRange{jP})));
0452         iCount = 0; <span class="comment">%counter of reactions to go</span>
0453         iSkip = 0; <span class="comment">%previously finished reactions</span>
0454         <span class="keyword">if</span> ~isempty(saveFVA)
0455             <span class="comment">%check if previous save of parallel computation exists</span>
0456             <span class="keyword">if</span> exist([saveFVA <span class="string">'_thread'</span> num2str(jP) <span class="string">'.mat'</span>], <span class="string">'file'</span>)
0457                 [minFluxP,maxFluxP,minFDP,maxFDP,iSkip] = <a href="#_sub2" class="code" title="subfunction [minFluxP,maxFluxP,minFDP,maxFDP,i0] = parLoad(jP,saveFVA)">parLoad</a>(jP,saveFVA);
0458                 fprintf(<span class="string">'Thread %d: continue FVA from i = %d.\n'</span>, jP, iSkip);
0459             <span class="keyword">end</span>
0460         <span class="keyword">end</span>
0461         <span class="keyword">for</span> i = rxnRange{jP}
0462             iCount = iCount + 1;
0463             <span class="keyword">if</span> i &gt; iSkip
0464                 <span class="comment">%maximize</span>
0465                 LPp.Model.obj = -full(objList(:,i));
0466                 LPp.solve();
0467                 <span class="keyword">while</span> ~isprop(LPp, <span class="string">'Solution'</span>)
0468                     <span class="keyword">try</span>
0469                         LPp.solve();
0470                     <span class="keyword">catch</span>
0471                         <span class="comment">%should not happen</span>
0472                         fprintf(<span class="string">'Error in solving!'</span>)
0473                     <span class="keyword">end</span>
0474                 <span class="keyword">end</span>
0475                 <span class="comment">%Infeasibility can occur occasionally. Keep trying to relax the maximum biomass</span>
0476                 eps0 = 1e-8;
0477                 <span class="keyword">while</span> ~(<a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LPp) &lt;= feasTol) &amp;&amp; eps0 * 10 &lt;= 1e-3 <span class="comment">%LP.Solution.status ~= 1</span>
0478                     eps0 = eps0 * 10;
0479                     LPp.Model.lhs(idRow) = BMmax0 * (1 - eps0);
0480                     LPp.solve();
0481                 <span class="keyword">end</span>
0482                 <span class="keyword">if</span> ~(<a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LPp) &lt;= feasTol)
0483                     <span class="comment">%infeasible (suggests numerical issues)</span>
0484                     maxFluxP(iCount) = NaN;
0485                     maxFDP(:,iCount) = NaN;
0486                 <span class="keyword">else</span>
0487                     <span class="comment">%LP.Solution.fval can sometimes return NaN even if a solution is found</span>
0488                     maxFluxP(iCount) = -LPp.Model.obj' * LPp.Solution.x;
0489                     maxFDP(:,iCount) = LPp.Solution.x(rxnFluxId);
0490                 <span class="keyword">end</span>
0491                 LPp.Model.lhs(idRow) = BMmax0;
0492                 
0493                 <span class="comment">%minimize</span>
0494                 LPp.Model.obj = full(objList(:,i));
0495                 LPp.solve();
0496                 <span class="keyword">while</span> ~isprop(LPp, <span class="string">'Solution'</span>)
0497                     <span class="keyword">try</span>
0498                         LPp.solve();
0499                     <span class="keyword">catch</span>
0500                         <span class="comment">%should not happen</span>
0501                         fprintf(<span class="string">'Error in solving!'</span>)
0502                     <span class="keyword">end</span>
0503                 <span class="keyword">end</span>
0504                 <span class="comment">%Infeasibility can occur occasionally. Keep trying to relax the maximum biomass</span>
0505                 eps0 = 1e-8;
0506                 <span class="keyword">while</span> ~(<a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LPp) &lt;= feasTol) &amp;&amp; eps0 * 10 &lt;= 1e-3 <span class="comment">%LP.Solution.status ~= 1</span>
0507                     eps0 = eps0 * 10;
0508                     LPp.Model.lhs(idRow) = BMmax0 * (1 - eps0);
0509                     LPp.solve();
0510                 <span class="keyword">end</span>
0511                 <span class="keyword">if</span> ~(<a href="checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LPp) &lt;= feasTol)
0512                     minFluxP(iCount) = NaN;
0513                     minFDP(:,iCount) = NaN;
0514                 <span class="keyword">else</span>
0515                     minFluxP(iCount) = LPp.Model.obj' * LPp.Solution.x;
0516                     minFDP(:,iCount) = LPp.Solution.x(rxnFluxId);
0517                 <span class="keyword">end</span>
0518                 LPp.Model.lhs(idRow) = BMmax0;
0519 
0520                 <span class="keyword">if</span> mod(iCount, ceil(numel(rxnRange{jP})/10)) == 0 
0521                     <span class="keyword">if</span> (verbFlag)
0522                         fprintf(<span class="string">'Thread %d:\t%.2f%% finished. %04d-%02d-%02d %02d:%02d:%02.0f\n'</span>,<span class="keyword">...</span>
0523                             jP, iCount / numel(rxnRange{jP}) * 100, clock);
0524                     <span class="keyword">end</span>
0525                     <span class="comment">%save intermediate data</span>
0526                     <span class="keyword">if</span> ~isempty(saveFVA)
0527                         <a href="#_sub1" class="code" title="subfunction parSave(minFluxP,maxFluxP,minFDP,maxFDP,i0,jP,saveFVA)">parSave</a>(minFluxP,maxFluxP,minFDP,maxFDP,i,jP,saveFVA)
0528                     <span class="keyword">end</span>
0529                 <span class="keyword">end</span>
0530             <span class="keyword">end</span>
0531         <span class="keyword">end</span>
0532         <span class="keyword">if</span> ~isempty(saveFVA)
0533             <span class="comment">%save finished data for each thread</span>
0534             <a href="#_sub1" class="code" title="subfunction parSave(minFluxP,maxFluxP,minFDP,maxFDP,i0,jP,saveFVA)">parSave</a>(minFluxP,maxFluxP,minFDP,maxFDP,i,jP,saveFVA)
0535         <span class="keyword">end</span>
0536         maxFluxCell{jP} = maxFluxP;
0537         minFluxCell{jP} = minFluxP;
0538         maxFDCell{jP} = maxFDP;
0539         minFDCell{jP} = minFDP;
0540     <span class="keyword">end</span>
0541     <span class="comment">%collect all results</span>
0542     [maxFlux, minFlux, minFD, maxFD] = deal([]);
0543     <span class="keyword">if</span> exist([saveFVA <span class="string">'.mat'</span>], <span class="string">'file'</span>)
0544         load([saveFVA <span class="string">'.mat'</span>],<span class="string">'minFlux'</span>,<span class="string">'maxFlux'</span>,<span class="string">'minFD'</span>,<span class="string">'maxFD'</span>); 
0545     <span class="keyword">end</span>
0546     <span class="keyword">for</span> jP = 1:numPool
0547         maxFlux = [maxFlux; maxFluxCell{jP}];
0548         minFlux = [minFlux; minFluxCell{jP}];
0549         maxFD = [maxFD maxFDCell{jP}];
0550         minFD = [minFD minFDCell{jP}];
0551         maxFluxCell{jP} = [];
0552         minFluxCell{jP} = [];
0553         maxFDCell{jP} = [];
0554         minFDCell{jP} = [];
0555     <span class="keyword">end</span>
0556     <span class="keyword">if</span> ~isempty(saveFVA)
0557         i0 = size(objList,2);
0558         save([saveFVA <span class="string">'.mat'</span>],<span class="string">'i0'</span>,<span class="string">'minFlux'</span>,<span class="string">'maxFlux'</span>,<span class="string">'minFD'</span>,<span class="string">'maxFD'</span>);
0559     <span class="keyword">end</span>
0560 <span class="keyword">end</span>
0561 
0562 maxFlux = columnVector(maxFlux);
0563 minFlux = columnVector(minFlux);
0564 <span class="keyword">end</span>
0565 
0566 <a name="_sub1" href="#_subfunctions" class="code">function parSave(minFluxP,maxFluxP,minFDP,maxFDP,i0,jP,saveFVA)</a>
0567 save([saveFVA <span class="string">'_thread'</span> num2str(jP) <span class="string">'.mat'</span>],<span class="keyword">...</span>
0568     <span class="string">'i0'</span>,<span class="string">'minFluxP'</span>,<span class="string">'maxFluxP'</span>,<span class="string">'minFDP'</span>,<span class="string">'maxFDP'</span>,<span class="string">'jP'</span>)
0569 <span class="keyword">end</span>
0570 
0571 <a name="_sub2" href="#_subfunctions" class="code">function [minFluxP,maxFluxP,minFDP,maxFDP,i0] = parLoad(jP,saveFVA)</a>
0572 load([saveFVA <span class="string">'_thread'</span> num2str(jP) <span class="string">'.mat'</span>],<span class="keyword">...</span>
0573     <span class="string">'i0'</span>,<span class="string">'minFluxP'</span>,<span class="string">'maxFluxP'</span>,<span class="string">'minFDP'</span>,<span class="string">'maxFDP'</span>)
0574 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sat 06-May-2017 09:26:04 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>