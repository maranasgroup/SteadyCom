<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SteadyComCplex</title>
  <meta name="keywords" content="SteadyComCplex">
  <meta name="description" content="Find the maximum community growth rate at community steady-state using SteadyCom">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html SteadyCom -->
<h1>SteadyComCplex
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Find the maximum community growth rate at community steady-state using SteadyCom</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">Find the maximum community growth rate at community steady-state using SteadyCom
Call the CPLEX dynamic object directly.

[sol, result, LP,LP2,indLP] = SteadyComCplex(modelCom,options, solverParam)

INPUT
 modelCom   community COBRA model created with crateCommModel.m 
 (the following fields are required - others can be supplied)
   S            Stoichiometric matrix
   b            Right hand side
   c            Objective coefficients
   lb           Lower bounds
   ub           Upper bounds
 (at least one of the below two is needed)
   infoCom      structure containing community reaction info 
   indCom       the index structure corresponding to infoCom
                (returned along with the community model created with createCommModel) 

 options (optional)   struct with the following possible fields:
 (for constraining individual growth rates and biomass amounts, default [])
   GRfx            Fixed growth rate for species apart from the community
                   (N_species x 1 vector, NaN for unfixed growth rate,
                    or [#species | value]) e.g. to fix species 2, 3 
                   at growth rate 0.1, GRfx = [2, 0.1; 3, 0.1];
   BMcon           Biomass constraint matrix (sum(a_ij * X_j) &lt;/=/&gt; b_i)
                   (given as K x N_species matrix for K constraints)
                   e.g. [0 1 1 0] for X_2 + X_3 in a 4-species model
   BMrhs           RHS for BMcon, K x 1 vector for K constraints
   BMcsense        Sense of the constraint, 'L', 'E', 'G' for &lt;=, =, &gt;=
 (for general constraints on e.g. total carbon uptake, molecular crowding, default [])
   MC              K x (N_rxns+N_species) coefficient matrix, for K additional constraints
   MCmode          K x (N_rxns+N_species) matrix , with number 0 ~ 3
                   0: original variable
                   1: positive part of the variable
                   2: negative part of the variable
                   3: absolute value of the variable
   MCrhs           RHS of the constraints (optional, default all zeros)
   MClhs           LHS of the constraints (optional, default -inf)
 (parameters in the iterative algorithm, [default value])
   GRguess [0.2]   Initial guess of the growth rate.
   feasCrit [1]    Criteria for feasibility, 1, 2 or 3.
          The algorithm tests iteratively at a given growth rate
          whether a feasible solution can be found.
           1: Use a threshold total biomass BMweight (see below).
              i.e. sum(X) &gt;= BMweight
              (use it if the total biomass is known)
           2: Use a threshold on minimum biomass production
              (=specific growth rate x sum(biomass), which is roughly 
              constant over a range of growth rate if the sum of biomass 
              is not bounded above) 
              i.e. sum(X) * gr &gt;= BMtol * BMref * GR0
              where BMref is the maximum biomass at a small growth rate GR0
              and BMtol is a fraction ranging from 0 to 1
   algorithm [1]   algorithm to find the maximum growth rate
           1. Fzero after finding grLB and grUB with simple guessing [gr' = gr * sum(X)/sum(X')]
           2. Simple guessing with minimum one percent step size
           3. Bisection method
   BMweight [1]    Minimum total biomass for feasibility. Used only if feasCrit = 1
                   Set BMweight to a close-to-zero value to compute the
                   wash-out dilution rate.
   GR0 [0.001]     A small growth rate to obtain a reference value for
                   maximum total biomass production. 
                   Used only if feasCrit = 2 or solveGR0 = true
   BMtol [0.8]     Fractional tolerance for biomass production to check
                   feasibility. Used only if feasCrit = 2
   solveGR0[false] true to first solve the model at a low growth rate GR0
   GRtol [1e-6]    Precision for the growth rate found (grUB - grLB &lt; GRtol)
   BMtolAbs [1e-5] Absolute tolerance for positivity of biomass
   maxIter (1e3)   maximum nummber of iteration
 (parameters in the optimization model, [default value])
   minNorm [0]     0: No minNorm. 1: min sum of absolution flux of the final solution.
   BMgdw [all 1s]  The gram dry weight per mmol of the biomass reaction of
                   each organism. Maybe used to scale the biomass reactions between species.
   BMobj [all 1s]  Objective coefficient for the biomass of each species
                   when doing the maximization at each step. Maybe used to
                   scale the biomass reactions between species.
 (other parameters)
   verbFlag  [3]   Print level
                   0, 1, 2, 3 for silence, one log per 10, 5 (default) or 1
                   iteration respectively
   LPonly [false]  Return the initial LP at zero growth rate only. Calculate nothing.
   saveModel ['']  String, if non-empty, save the cplex model, basis and parameters.

 solverParam       Cplex parameter structure. E.g., struct('simplex',struct('tolerances',struct('feasibility',1e-8)))

OUTPUT
 sol: cplex solution structure
 result: structure with the following fields:
   GRmax:          maximum specific growth rate found (/h)
   vBM:            biomass formation rate (gdw/h)
   BM:             Biomass vector at GRmax (gdw)
   Ut:             uptake fluxes (mmol/h)
   Ex:             export fluxes (mmol/h)
   flux:           flux distribution for the original model
   (the following 'iter' fields are status in each iteration:)
   [GR | biomass X | biomass flux (GR * X) | max. infeas. of solution])
   iter0:          stationary, no growth, gr = 0
   iter1:          small growth rate, gr = GR0
   iterPre:        iterations for finding upper and lower bounds
   iter:           iterations for finding max gr using bisectional method
   stat:           status at the termination of the algorithm
                   infeasible: infeasible model, even with maintenance
                               requirement only
                   maintenance:feasible at maintenance, but cannot grow
                   optimal:    optimal growth rate found</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>	Check the feasibility of a solution given a COBRA model structure or a CPLEX dynamic object and a solution</li><li><a href="../SteadyCom/auxiliary_functions/getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>	get the required default parameters</li><li><a href="../SteadyCom/auxiliary_functions/infoCom2indCom.html" class="code" title="function indCom = infoCom2indCom(modelCom,infoCom,revFlag,spAbbr,spName)">infoCom2indCom</a>	Transform between community reaction IDs and reaction names</li><li><a href="../SteadyCom/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>	Set the parameters of the CPLEX object according to the structure solverParam</li><li><a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>	Create and update the SteadyCom LP model in CPLEX format.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="SteadyComFVACplex.html" class="code" title="function [minFlux,maxFlux,minFD,maxFD, GRvector, result,LP] = SteadyComFVACplex(modelCom,options,solverParam)">SteadyComFVACplex</a>	Flux variability analysis for community model at community steady-state for a range of growth rates.</li><li><a href="SteadyComPOACplex.html" class="code" title="function [POAtable, fluxRange, Stat, GRvector] = SteadyComPOACplex(modelCom,options,solverParam)">SteadyComPOACplex</a>	Pairwise POA for community model at community steady-state for a range of growth rates</li><li><a href="../SteadyCom/auxiliary_functions/SteadyComFVAgrCplex.html" class="code" title="function [minFlux,maxFlux,minFD,maxFD,LP,GR] = SteadyComFVAgrCplex(modelCom,options,solverParam,LP)">SteadyComFVAgrCplex</a>	Flux variability analysis for community model at community steady-state at a given growth rate.</li><li><a href="../SteadyCom/auxiliary_functions/SteadyComPOAgrCplex.html" class="code" title="function [POAtable, fluxRange, Stat, pairList] = SteadyComPOAgrCplex(modelCom,options,solverParam,LP)">SteadyComPOAgrCplex</a>	Pairwise POA for community model at community steady-state at a given growth rate</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [LP,index] = constructLPcom(modelCom, options, solverParam)</a></li><li><a href="#_sub2" class="code">function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)</a></li><li><a href="#_sub3" class="code">function [paramList, paramPath] = getParamList(param, bottomFlag)</a></li><li><a href="#_sub4" class="code">function dBM = LP4fzero1(grCur, LP, modelCom, GRfx, feasTol, BMequiv,BMgdw)</a></li><li><a href="#_sub5" class="code">function dBM = LP4fzero2(grCur, LP, modelCom, GRfx, feasTol, BMequiv, GR0, BMgdw)</a></li><li><a href="#_sub6" class="code">function yn = ErrBecauseInfeas(ME)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP)</a>
0002 <span class="comment">%Find the maximum community growth rate at community steady-state using SteadyCom</span>
0003 <span class="comment">%Call the CPLEX dynamic object directly.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%[sol, result, LP,LP2,indLP] = SteadyComCplex(modelCom,options, solverParam)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%INPUT</span>
0008 <span class="comment">% modelCom   community COBRA model created with crateCommModel.m</span>
0009 <span class="comment">% (the following fields are required - others can be supplied)</span>
0010 <span class="comment">%   S            Stoichiometric matrix</span>
0011 <span class="comment">%   b            Right hand side</span>
0012 <span class="comment">%   c            Objective coefficients</span>
0013 <span class="comment">%   lb           Lower bounds</span>
0014 <span class="comment">%   ub           Upper bounds</span>
0015 <span class="comment">% (at least one of the below two is needed)</span>
0016 <span class="comment">%   infoCom      structure containing community reaction info</span>
0017 <span class="comment">%   indCom       the index structure corresponding to infoCom</span>
0018 <span class="comment">%                (returned along with the community model created with createCommModel)</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% options (optional)   struct with the following possible fields:</span>
0021 <span class="comment">% (for constraining individual growth rates and biomass amounts, default [])</span>
0022 <span class="comment">%   GRfx            Fixed growth rate for species apart from the community</span>
0023 <span class="comment">%                   (N_species x 1 vector, NaN for unfixed growth rate,</span>
0024 <span class="comment">%                    or [#species | value]) e.g. to fix species 2, 3</span>
0025 <span class="comment">%                   at growth rate 0.1, GRfx = [2, 0.1; 3, 0.1];</span>
0026 <span class="comment">%   BMcon           Biomass constraint matrix (sum(a_ij * X_j) &lt;/=/&gt; b_i)</span>
0027 <span class="comment">%                   (given as K x N_species matrix for K constraints)</span>
0028 <span class="comment">%                   e.g. [0 1 1 0] for X_2 + X_3 in a 4-species model</span>
0029 <span class="comment">%   BMrhs           RHS for BMcon, K x 1 vector for K constraints</span>
0030 <span class="comment">%   BMcsense        Sense of the constraint, 'L', 'E', 'G' for &lt;=, =, &gt;=</span>
0031 <span class="comment">% (for general constraints on e.g. total carbon uptake, molecular crowding, default [])</span>
0032 <span class="comment">%   MC              K x (N_rxns+N_species) coefficient matrix, for K additional constraints</span>
0033 <span class="comment">%   MCmode          K x (N_rxns+N_species) matrix , with number 0 ~ 3</span>
0034 <span class="comment">%                   0: original variable</span>
0035 <span class="comment">%                   1: positive part of the variable</span>
0036 <span class="comment">%                   2: negative part of the variable</span>
0037 <span class="comment">%                   3: absolute value of the variable</span>
0038 <span class="comment">%   MCrhs           RHS of the constraints (optional, default all zeros)</span>
0039 <span class="comment">%   MClhs           LHS of the constraints (optional, default -inf)</span>
0040 <span class="comment">% (parameters in the iterative algorithm, [default value])</span>
0041 <span class="comment">%   GRguess [0.2]   Initial guess of the growth rate.</span>
0042 <span class="comment">%   feasCrit [1]    Criteria for feasibility, 1, 2 or 3.</span>
0043 <span class="comment">%          The algorithm tests iteratively at a given growth rate</span>
0044 <span class="comment">%          whether a feasible solution can be found.</span>
0045 <span class="comment">%           1: Use a threshold total biomass BMweight (see below).</span>
0046 <span class="comment">%              i.e. sum(X) &gt;= BMweight</span>
0047 <span class="comment">%              (use it if the total biomass is known)</span>
0048 <span class="comment">%           2: Use a threshold on minimum biomass production</span>
0049 <span class="comment">%              (=specific growth rate x sum(biomass), which is roughly</span>
0050 <span class="comment">%              constant over a range of growth rate if the sum of biomass</span>
0051 <span class="comment">%              is not bounded above)</span>
0052 <span class="comment">%              i.e. sum(X) * gr &gt;= BMtol * BMref * GR0</span>
0053 <span class="comment">%              where BMref is the maximum biomass at a small growth rate GR0</span>
0054 <span class="comment">%              and BMtol is a fraction ranging from 0 to 1</span>
0055 <span class="comment">%   algorithm [1]   algorithm to find the maximum growth rate</span>
0056 <span class="comment">%           1. Fzero after finding grLB and grUB with simple guessing [gr' = gr * sum(X)/sum(X')]</span>
0057 <span class="comment">%           2. Simple guessing with minimum one percent step size</span>
0058 <span class="comment">%           3. Bisection method</span>
0059 <span class="comment">%   BMweight [1]    Minimum total biomass for feasibility. Used only if feasCrit = 1</span>
0060 <span class="comment">%                   Set BMweight to a close-to-zero value to compute the</span>
0061 <span class="comment">%                   wash-out dilution rate.</span>
0062 <span class="comment">%   GR0 [0.001]     A small growth rate to obtain a reference value for</span>
0063 <span class="comment">%                   maximum total biomass production.</span>
0064 <span class="comment">%                   Used only if feasCrit = 2 or solveGR0 = true</span>
0065 <span class="comment">%   BMtol [0.8]     Fractional tolerance for biomass production to check</span>
0066 <span class="comment">%                   feasibility. Used only if feasCrit = 2</span>
0067 <span class="comment">%   solveGR0[false] true to first solve the model at a low growth rate GR0</span>
0068 <span class="comment">%   GRtol [1e-6]    Precision for the growth rate found (grUB - grLB &lt; GRtol)</span>
0069 <span class="comment">%   BMtolAbs [1e-5] Absolute tolerance for positivity of biomass</span>
0070 <span class="comment">%   maxIter (1e3)   maximum nummber of iteration</span>
0071 <span class="comment">% (parameters in the optimization model, [default value])</span>
0072 <span class="comment">%   minNorm [0]     0: No minNorm. 1: min sum of absolution flux of the final solution.</span>
0073 <span class="comment">%   BMgdw [all 1s]  The gram dry weight per mmol of the biomass reaction of</span>
0074 <span class="comment">%                   each organism. Maybe used to scale the biomass reactions between species.</span>
0075 <span class="comment">%   BMobj [all 1s]  Objective coefficient for the biomass of each species</span>
0076 <span class="comment">%                   when doing the maximization at each step. Maybe used to</span>
0077 <span class="comment">%                   scale the biomass reactions between species.</span>
0078 <span class="comment">% (other parameters)</span>
0079 <span class="comment">%   verbFlag  [3]   Print level</span>
0080 <span class="comment">%                   0, 1, 2, 3 for silence, one log per 10, 5 (default) or 1</span>
0081 <span class="comment">%                   iteration respectively</span>
0082 <span class="comment">%   LPonly [false]  Return the initial LP at zero growth rate only. Calculate nothing.</span>
0083 <span class="comment">%   saveModel ['']  String, if non-empty, save the cplex model, basis and parameters.</span>
0084 <span class="comment">%</span>
0085 <span class="comment">% solverParam       Cplex parameter structure. E.g., struct('simplex',struct('tolerances',struct('feasibility',1e-8)))</span>
0086 <span class="comment">%</span>
0087 <span class="comment">%OUTPUT</span>
0088 <span class="comment">% sol: cplex solution structure</span>
0089 <span class="comment">% result: structure with the following fields:</span>
0090 <span class="comment">%   GRmax:          maximum specific growth rate found (/h)</span>
0091 <span class="comment">%   vBM:            biomass formation rate (gdw/h)</span>
0092 <span class="comment">%   BM:             Biomass vector at GRmax (gdw)</span>
0093 <span class="comment">%   Ut:             uptake fluxes (mmol/h)</span>
0094 <span class="comment">%   Ex:             export fluxes (mmol/h)</span>
0095 <span class="comment">%   flux:           flux distribution for the original model</span>
0096 <span class="comment">%   (the following 'iter' fields are status in each iteration:)</span>
0097 <span class="comment">%   [GR | biomass X | biomass flux (GR * X) | max. infeas. of solution])</span>
0098 <span class="comment">%   iter0:          stationary, no growth, gr = 0</span>
0099 <span class="comment">%   iter1:          small growth rate, gr = GR0</span>
0100 <span class="comment">%   iterPre:        iterations for finding upper and lower bounds</span>
0101 <span class="comment">%   iter:           iterations for finding max gr using bisectional method</span>
0102 <span class="comment">%   stat:           status at the termination of the algorithm</span>
0103 <span class="comment">%                   infeasible: infeasible model, even with maintenance</span>
0104 <span class="comment">%                               requirement only</span>
0105 <span class="comment">%                   maintenance:feasible at maintenance, but cannot grow</span>
0106 <span class="comment">%                   optimal:    optimal growth rate found</span>
0107 <span class="comment">%</span>
0108 <span class="comment">%</span>
0109 t = tic;
0110 t0 = 0;
0111 <span class="comment">%% Initialization</span>
0112 <span class="comment">%check required fields for community model</span>
0113 <span class="keyword">if</span> ~isfield(modelCom,<span class="string">'indCom'</span>)
0114     <span class="keyword">if</span> ~isfield(modelCom,<span class="string">'infoCom'</span>) || ~isstruct(modelCom.infoCom) || <span class="keyword">...</span>
0115             ~all(isfield(modelCom.infoCom,{<span class="string">'spBm'</span>,<span class="string">'EXcom'</span>,<span class="string">'EXsp'</span>,<span class="string">'spAbbr'</span>,<span class="string">'rxnSps'</span>,<span class="string">'metSps'</span>}))
0116         error(<span class="string">'infoCom must be provided for calculating the max. community growth rate.\n'</span>);
0117     <span class="keyword">end</span>
0118     <span class="comment">%get useful reaction indices</span>
0119     modelCom.indCom = <a href="../SteadyCom/auxiliary_functions/infoCom2indCom.html" class="code" title="function indCom = infoCom2indCom(modelCom,infoCom,revFlag,spAbbr,spName)">infoCom2indCom</a>(modelCom);
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">%get paramters</span>
0123 <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>)
0124     options = struct();
0125 <span class="keyword">end</span>
0126 <span class="keyword">if</span> ~exist(<span class="string">'solverParam'</span>, <span class="string">'var'</span>) || isempty(solverParam)
0127     <span class="comment">%default Cplex parameters</span>
0128     solverParam = <a href="../SteadyCom/auxiliary_functions/getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>(<span class="string">'CplexParam'</span>);
0129 <span class="keyword">end</span>
0130 param2get = {<span class="string">'GRguess'</span>, <span class="string">'GR0'</span>, <span class="string">'GRfx'</span>, <span class="string">'GRtol'</span>, <span class="string">'solveGR0'</span>,<span class="keyword">...</span>
0131              <span class="string">'BMweight'</span>, <span class="string">'BMtol'</span>, <span class="string">'BMtolAbs'</span>, <span class="string">'BMgdw'</span>,<span class="keyword">...</span>
0132              <span class="string">'feasCrit'</span>, <span class="string">'maxIter'</span>, <span class="string">'verbFlag'</span>, <span class="string">'algorithm'</span>,<span class="keyword">...</span>
0133              <span class="string">'minNorm'</span>, <span class="string">'LPonly'</span>, <span class="string">'saveModel'</span>};
0134 eval(sprintf(<span class="string">'[%s] = getCobraComParams(param2get, options, modelCom);'</span>, <span class="keyword">...</span>
0135             strjoin(param2get, <span class="string">','</span>)<span class="keyword">...</span>
0136             )<span class="keyword">...</span>
0137     );
0138 <span class="comment">%print level</span>
0139 pL = [0 10 5 1];
0140 pL = pL(verbFlag + 1);
0141 
0142 [m, n] = size(modelCom.S); <span class="comment">%model size</span>
0143 nRxnSp = sum(modelCom.indCom.rxnSps &gt; 0); <span class="comment">%number of organism-specific rxns</span>
0144 nSp = numel(modelCom.indCom.spBm); <span class="comment">%number of organism</span>
0145 
0146 <span class="keyword">if</span> verbFlag &amp;&amp; ~LPonly
0147     fprintf(<span class="string">'Find maximum community growth rate..\n'</span>);
0148 <span class="keyword">end</span>
0149 <span class="comment">%% Construct LP</span>
0150 
0151 <span class="keyword">if</span> nargin &lt; 4
0152     <span class="comment">%create the CPLEX LP problem if not given</span>
0153     [LP,indLP] = <a href="#_sub1" class="code" title="subfunction [LP,index] = constructLPcom(modelCom, options, solverParam)">constructLPcom</a>(modelCom, options, solverParam);
0154 <span class="keyword">else</span>
0155     <span class="comment">% LP given: delete the row constraining the sum of biomass if exist</span>
0156     f = find(strcmp(cellstr(LP.Model.rowname),<span class="string">'UnityBiomass'</span>));
0157     <span class="keyword">if</span> ~isempty(f)
0158         LP.delRows(f);
0159     <span class="keyword">end</span>
0160     LP.Model.obj(n+1:n+nSp) = 1;
0161     LP.Model.sense = <span class="string">'maximize'</span>;
0162     indLP = [];
0163 <span class="keyword">end</span>
0164 <span class="comment">% Make sure the feasibility tolerance used in CPLEX and in the main loop</span>
0165 <span class="comment">% are the same ('constructLPcom' has already reconciled the two tolerances)</span>
0166 feasTol = LP.Param.simplex.tolerances.feasibility.Cur;
0167 LP2 = [];
0168 <span class="comment">% terminate if only the LP structure is called as output</span>
0169 <span class="keyword">if</span> LPonly
0170     result = struct();
0171     [result.GRmax, result.vBM, result.BM, result.Ut, result.Ex, <span class="keyword">...</span>
0172         result.flux, result.iter, result.iter0, sol] = deal([]);
0173     result.stat = <span class="string">'LPonly'</span>;
0174     <span class="keyword">return</span>
0175 <span class="keyword">end</span>
0176 
0177 <span class="comment">%counter for iteration</span>
0178 k = 0;
0179 iter = [];
0180 
0181 <span class="comment">% if LP is supplied by user, directly jump to the main loop</span>
0182 <span class="keyword">if</span> nargin &lt; 4
0183     <span class="comment">%% Test the ability of the model to stay at maintenance only.</span>
0184     
0185     <span class="comment">%solve for maintenance (zero growth)</span>
0186     <span class="comment">%This step usually costs very little time. Worth doing to confirm</span>
0187     <span class="comment">%feasibility</span>
0188     feas = true;
0189     <span class="keyword">try</span>
0190         LP.solve();
0191     <span class="keyword">catch</span> ME
0192         <span class="comment">%possible internal error of cplex</span>
0193         <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0194             <span class="comment">%treat as infeasible</span>
0195             feas = false;
0196         <span class="keyword">else</span>
0197             disp(ME);
0198             error(<span class="string">'Unknown error from CPLEX.'</span>);
0199         <span class="keyword">end</span>
0200     <span class="keyword">end</span>
0201         
0202     <span class="comment">% check the feasibility of the solution manually</span>
0203     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0204 
0205     result = struct();
0206     [result.GRmax, result.vBM, result.BM, result.Ut, result.Ex, result.flux, <span class="keyword">...</span>
0207         result.iter0, result.iter, result.stat] = deal([]);
0208     <span class="comment">%terminate if time limit has been exceeded.</span>
0209     <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0210         result.stat = <span class="string">'time limit exceeded'</span>;
0211         sol = [];
0212         <span class="keyword">return</span>
0213     <span class="keyword">end</span>
0214     <span class="comment">%biomass at zero growth rate</span>
0215     BM0 = 0;
0216     <span class="keyword">if</span> feas &amp;&amp; isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
0217         <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
0218             <span class="comment">%if feasible</span>
0219             BM0 = LP.Model.obj' * LP.Solution.x;
0220         <span class="keyword">end</span>
0221     <span class="keyword">end</span>
0222     <span class="keyword">if</span> BM0 &lt; BMtolAbs
0223         <span class="comment">%if no biomass is formed, infeasible. Terminate.</span>
0224         <span class="keyword">if</span> verbFlag
0225             t0 = toc(t);
0226             fprintf(<span class="string">'Model infeasible at maintenance. Time elapsed: %.0f / %.0f sec\n'</span>, t0, t0);
0227         <span class="keyword">end</span>
0228         sol = [];
0229         result.stat = <span class="string">'infeasible'</span>;
0230         LP2 = [];
0231         <span class="keyword">return</span>
0232     <span class="keyword">else</span>
0233         <span class="comment">%record the current result if feasible</span>
0234         <span class="keyword">if</span> verbFlag
0235             t0 = toc(t);
0236             fprintf(<span class="string">'Model feasible at maintenance. Time elapsed: %.0f / %.0f sec\n'</span>, t0, t0);
0237         <span class="keyword">end</span>
0238         sol = LP.Solution;
0239         <span class="keyword">if</span> ~isempty(saveModel)
0240             LP.writeBasis([saveModel <span class="string">'.bas'</span>]);
0241         <span class="keyword">end</span>
0242         result.GRmax = 0;
0243         result.vBM = LP.Solution.x(modelCom.indCom.spBm);
0244         result.BM = LP.Solution.x(n + 1 : n + nSp);
0245         result.BM(abs(result.BM) &lt; 1e-8) = 0;
0246         result.Ut = LP.Solution.x(modelCom.indCom.EXcom(:,1));
0247         result.Ex = LP.Solution.x(modelCom.indCom.EXcom(:,2));
0248         result.flux = LP.Solution.x(1:n);
0249         result.iter0 = [0 BM0 0 dev];
0250         result.iter = [];
0251         result.stat = <span class="string">'maintenance'</span>;
0252     <span class="keyword">end</span>
0253 
0254     <span class="comment">%% Test at very small growth rate to see if the model is able to grow</span>
0255     <span class="comment">% only if using the reference biomass at GR0 to define maximum growth rate</span>
0256     <span class="keyword">if</span> feasCrit == 2 || solveGR0
0257         <span class="comment">%update the growth rate</span>
0258         LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, GR0, GRfx, [], LP.Model.A, BMgdw);
0259         feas = true;
0260         <span class="keyword">try</span>
0261             LP.solve();
0262         <span class="keyword">catch</span> ME
0263             <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0264                 <span class="comment">%treat as infeasible</span>
0265                 feas = false;
0266             <span class="keyword">else</span>
0267                 disp(ME);
0268                 error(<span class="string">'Unknown error from CPLEX.'</span>);
0269             <span class="keyword">end</span>
0270         <span class="keyword">end</span>
0271         <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0272             result.stat = <span class="string">'time limit exceeded'</span>;
0273             sol = [];
0274             LP2 = [];
0275             <span class="keyword">return</span>
0276         <span class="keyword">end</span>
0277         <span class="comment">% check the feasibility of the solution manually</span>
0278         dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0279         <span class="comment">%biomass for reference (at a very low growth rate)</span>
0280         BMref = 0;
0281         <span class="keyword">if</span> feas &amp;&amp; isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
0282             <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
0283                 BMref = LP.Model.obj' * LP.Solution.x;
0284             <span class="keyword">end</span>
0285         <span class="keyword">end</span>
0286 
0287         iter = [iter; 0 GR0 BMref GR0 * BMref dev 0];
0288         <span class="keyword">if</span> BMref &lt; BMtolAbs
0289             <span class="comment">%if no biomass can be formed, the model can only stay at maintenance.</span>
0290             <span class="keyword">if</span> verbFlag
0291                 t1 = toc(t);
0292                 fprintf(<span class="string">'Model infeasible at a minimal growth rate (%.6f). Time elapsed: %.0f / %.0f sec\n.'</span>, GR0, t1 - t0, t1);
0293             <span class="keyword">end</span>
0294             result.iter = iter;
0295             <span class="keyword">return</span>
0296         <span class="keyword">else</span>
0297             <span class="comment">%able to grow. Compute bounds</span>
0298             <span class="keyword">if</span> verbFlag
0299                 t1 = toc(t);
0300                 fprintf(<span class="string">'Model feasible at a minimal growth (%.6f). Time elapsed: %.0f / %.0f sec.\nLook for upper and lower bounds...\n'</span>, GR0, t1 - t0, t1);
0301                 t0 = t1;
0302             <span class="keyword">end</span>
0303             sol = LP.Solution;
0304             <span class="keyword">if</span> ~isempty(saveModel)
0305                 LP.writeBasis([saveModel <span class="string">'.bas'</span>]);
0306             <span class="keyword">end</span>
0307             result.GRmax = GR0;
0308             result.vBM = LP.Solution.x(modelCom.indCom.spBm);
0309             result.BM = LP.Solution.x(n + 1 : n + nSp);
0310             result.BM(abs(result.BM) &lt; 1e-8) = 0;
0311             result.Ut = LP.Solution.x(modelCom.indCom.EXcom(:,1));
0312             result.Ex = LP.Solution.x(modelCom.indCom.EXcom(:,2));
0313             result.flux = LP.Solution.x(1:n);
0314             result.stat = <span class="string">'minimal growth'</span>;
0315         <span class="keyword">end</span>
0316     <span class="keyword">end</span>
0317     <span class="comment">%initial growth rate</span>
0318     grCur = GRguess(1);
0319 <span class="keyword">else</span>
0320     <span class="comment">% if LP is given, assume it has a starting basis for the growth rate</span>
0321     <span class="comment">% encoded in the problem. Start from there should give quick</span>
0322     <span class="comment">% convergence</span>
0323     jSpGrCur = find(isnan(GRfx),1);
0324     <span class="comment">%initial growth rate</span>
0325     grCur = full(abs(LP.Model.A(m + 2*nRxnSp + jSpGrCur, n + jSpGrCur)));
0326 <span class="keyword">end</span>
0327 
0328 <span class="comment">%% main loop to solve for maximum growth rate</span>
0329 
0330 <span class="comment">%feasibility criteria</span>
0331 <span class="keyword">switch</span> feasCrit
0332     <span class="comment">%condition1 for determining the feasibility of the current growth rate</span>
0333     <span class="comment">%condition2 for ensuring the final feasibility after the max growth</span>
0334     <span class="comment">%rate is found</span>
0335     <span class="keyword">case</span> 1
0336         <span class="comment">%maximum growth rate given a fixed total community biomass, defaulted to be 1</span>
0337         BMequiv = BMweight;
0338         condition1 = @(BMcur, grCur) BMcur &gt;= BMweight;
0339         condition2 = @(BMcur, grCur) BMcur &gt;= BMweight * (1 - BMtolAbs);
0340         <span class="comment">%guess for grCur</span>
0341         updateGRguess = @(BMcur, grCur) grCur * BMcur / BMweight;
0342         LP4fzero = @(grCur, LP)<span class="keyword">...</span>
0343             <a href="#_sub4" class="code" title="subfunction dBM = LP4fzero1(grCur, LP, modelCom, GRfx, feasTol, BMequiv,BMgdw)">LP4fzero1</a>(grCur, LP, modelCom, GRfx, feasTol, BMequiv, BMgdw);
0344     <span class="keyword">case</span> 2
0345         <span class="comment">%maximum growth rate with production rate of community biomass not</span>
0346         <span class="comment">%less than the reference value at growth rate GR0</span>
0347         BMequiv = BMtol * BMref;
0348         condition1 = @(BMcur, grCur) BMcur * grCur &gt;= BMtol * BMref * GR0;
0349         condition2 = @(BMcur, grCur) BMcur * grCur &gt;= BMtol * BMref * GR0 * (1 - BMtolAbs);
0350         <span class="comment">%guess for grCur</span>
0351         updateGRguess = @(BMcur, grCur) grCur * BMcur / (BMtol * BMref * GR0);
0352         LP4fzero = @(grCur, LP)<span class="keyword">...</span>
0353             <a href="#_sub5" class="code" title="subfunction dBM = LP4fzero2(grCur, LP, modelCom, GRfx, feasTol, BMequiv, GR0, BMgdw)">LP4fzero2</a>(grCur, LP, modelCom, GRfx, feasTol, BMequiv, GR0, BMgdw);
0354 <span class="keyword">end</span>
0355 
0356 grLB = 0;<span class="comment">%lower bound for growth rate</span>
0357 grUB = Inf;<span class="comment">%upper bound for growth rate</span>
0358 grLBrecord = grLB;<span class="comment">%vector recording all intermediate grLB</span>
0359 grUBrecord = grUB;<span class="comment">%vector recording all intermediate grUB</span>
0360 guessMethod = 0; <span class="comment">%guess used for updating the growth rate</span>
0361 numInstab = false; <span class="comment">%flag for numerical instability</span>
0362 grUnstable = []; <span class="comment">%growth rate at which numerical instability occurs</span>
0363 optionsf0 = optimset; <span class="comment">%matlab optimization parameters</span>
0364 <span class="keyword">switch</span> pL
0365     <span class="keyword">case</span> 0
0366         optionsf0.Display = <span class="string">'off'</span>;
0367     <span class="keyword">case</span> 10
0368         optionsf0.Display = <span class="string">'final'</span>;
0369     <span class="keyword">case</span> 5
0370         optionsf0.Display = <span class="string">'notify'</span>;
0371     <span class="keyword">case</span> 1
0372         optionsf0.Display = <span class="string">'iter'</span>;
0373 <span class="keyword">end</span>
0374 optionsf0.MaxIter = maxIter; <span class="comment">%max. number of iteration</span>
0375 optionsf0.TolX = GRtol; <span class="comment">%tolerance for the root found</span>
0376 <span class="comment">% optionsf0.TolFun = BMtolAbs;</span>
0377 
0378 <span class="comment">%Finding an interval for the max. growth rate using the simple guess</span>
0379 <span class="comment">%growth rate x max(biomass) = constant</span>
0380 <span class="comment">%apparently better than guess by matlab fzero</span>
0381 <span class="comment">%Then initiate fzero or continue using simple guess or bisection depending</span>
0382 <span class="comment">%on the parameter 'algorithm'</span>
0383 col1disp = num2str(max([log10(maxIter)+1,4]));
0384 <span class="keyword">if</span> pL
0385     fprintf([<span class="string">'%'</span> col1disp <span class="string">'s  %8s  %8s  %8s  Time elapsed (iteration/total)\n'</span>],<span class="keyword">...</span>
0386         <span class="string">'Iter'</span>,<span class="string">'LB'</span>,<span class="string">'To test'</span>, <span class="string">'UB'</span>);
0387 <span class="keyword">end</span>
0388 <span class="keyword">if</span> 0
0389     <span class="comment">%totally solved by fzero (unused)</span>
0390     GRmax = fzero(@(x) LP4fzero(x, LP), grCur, optionsf0);
0391 <span class="keyword">else</span>
0392     k1LB = false; <span class="comment">%lower bound found at k = 1</span>
0393     <span class="comment">%If an LB is found at k = 1, kLU counts the number of LBs found.</span>
0394     <span class="comment">%If an UB is found at k = 1, kLU counts the number of UBs found.</span>
0395     kLU = 0; 
0396     <span class="keyword">while</span> true
0397         <span class="comment">%solve for initial guess</span>
0398         k = k + 1;
0399         <span class="keyword">if</span> mod(k, pL) == 0
0400             t1 = toc(t);
0401             <span class="keyword">if</span> ~numInstab
0402                 fprintf([<span class="string">'%'</span> col1disp <span class="string">'d  %8.6f  %8.6f  %8.6f  %.0f / %.0f sec\n'</span>],<span class="keyword">...</span>
0403                     k, grLB, grCur, grUB, t1 - t0, t1);
0404             <span class="keyword">else</span>
0405                 fprintf([<span class="string">'%'</span> col1disp <span class="string">'d  %8.6f  %8.6f  %8.6f  %.0f / %.0f sec (numerical instability)\n'</span>],<span class="keyword">...</span>
0406                     k, grLB, grCur, grUB, t1 - t0, t1);
0407                 numInstab = false;
0408             <span class="keyword">end</span>
0409             <span class="comment">%fprintf('%.0f\t%.6f\t%.6f\tTime elapsed: %.0f / %.0f sec\n', k, grLB, grUB, t1 - t0, t1);</span>
0410             t0 = t1;
0411         <span class="keyword">end</span>
0412         <span class="comment">%update growth rate</span>
0413         LP.Model.A = <a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, grCur, GRfx, [], LP.Model.A, BMgdw);
0414         feas = true;
0415         <span class="keyword">try</span>
0416             LP.solve();
0417         <span class="keyword">catch</span> ME
0418             <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0419                 <span class="comment">%treat as infeasible</span>
0420                 feas = false;
0421             <span class="keyword">else</span>
0422                 disp(ME);
0423                 error(<span class="string">'Unknown error from CPLEX.'</span>);
0424             <span class="keyword">end</span>
0425         <span class="keyword">end</span>
0426         <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0427             result.stat = <span class="string">'time limit exceeded'</span>;
0428             sol = [];
0429             LP2 = [];
0430             <span class="keyword">return</span>
0431         <span class="keyword">end</span>
0432         <span class="comment">% check the feasibility of the solution manually</span>
0433         dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0434         <span class="comment">%get biomass of the current iteration</span>
0435         BMcur = 0;
0436         <span class="keyword">if</span> feas &amp;&amp; isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
0437             <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
0438                 <span class="comment">%update the current biomass if successfully solved</span>
0439                 BMcur = LP.Model.obj' * LP.Solution.x;
0440             <span class="keyword">end</span>
0441             <span class="keyword">if</span> condition1(BMcur, grCur)
0442                 <span class="comment">%feasible at the current growth rate (sum(X) &gt;= X_0)</span>
0443                 grLB = grCur; <span class="comment">%an LB is found</span>
0444                 grLBrecord = [grLBrecord; grLB];
0445                 <span class="keyword">if</span> k == 1
0446                     k1LB = true;
0447                 <span class="keyword">end</span>
0448                 kLU = kLU + k1LB;
0449             <span class="keyword">else</span>
0450                 <span class="comment">%infeasible at the current growth rate (sum(X) &lt; X_0)</span>
0451                 grUB = grCur; <span class="comment">%an UB is found</span>
0452                 grUBrecord = [grUBrecord; grUB];
0453                 <span class="keyword">if</span> k == 1
0454                     k1LB = false;
0455                 <span class="keyword">end</span>
0456                 kLU = kLU + ~k1LB; 
0457             <span class="keyword">end</span>
0458         <span class="keyword">else</span>
0459             <span class="comment">%No solution</span>
0460             <span class="comment">%(can become infeasible because of numerical instability)</span>
0461             grUB = grCur;
0462             grUBrecord = [grUBrecord; grUB];
0463             <span class="keyword">if</span> k == 1
0464                 k1LB = false;
0465             <span class="keyword">end</span>
0466             kLU = kLU + ~k1LB;
0467         <span class="keyword">end</span>
0468         <span class="comment">%record results for the current iteration</span>
0469         iter = [iter; k, grCur, BMcur, grCur * BMcur, dev, guessMethod];    
0470         
0471         <span class="comment">% condition for switching to fzero or concluding GRmax = 0:</span>
0472         <span class="comment">%   kLU &gt;= 2 to ensure neither of the bounds is the initial guess.</span>
0473         <span class="comment">% Algorithm:</span>
0474         <span class="comment">%   1. Fzero after finding LB and UB by simple guessing [gr' = gr * sum(X)/sum(X')]</span>
0475         <span class="comment">%   2. Simple guessing with minimum one percent step size</span>
0476         <span class="comment">%   3. Bisection method</span>
0477         <span class="keyword">if</span> (grLB &gt; 0 &amp;&amp; grUB &lt; Inf &amp;&amp; kLU &gt;= 2 &amp;&amp; algorithm == 1)
0478             <span class="comment">%switch to fzero</span>
0479             dBMneg = LP4fzero(grLB, LP);<span class="comment">%expected to be -ve</span>
0480             dBMpos = LP4fzero(grUB, LP);<span class="comment">%expected to be +ve</span>
0481             <span class="keyword">if</span> isempty(dBMneg) || isempty(dBMpos)
0482                 result.stat = <span class="string">'time limit exceeded'</span>;
0483                 sol = [];
0484                 LP2 = [];
0485                 <span class="keyword">return</span>
0486             <span class="keyword">end</span>
0487             <span class="comment">%Check for numerical instability.</span>
0488             <span class="comment">% Can happens when the model is bounded such that the maximum growth rate</span>
0489             <span class="comment">% for the given biomass is close to the critical wash-out dilution rate</span>
0490             <span class="comment">% of the system. In this case, the maximum biomass sum(X) can drop very</span>
0491             <span class="comment">% abruptly with sum(X) ~ 0 at GRmax but sum(X) &gt;&gt; BMequiv at GRmax - eps.</span>
0492             <span class="comment">% Feasibility in this range returned by the solver is not trustworthy.</span>
0493             <span class="comment">% Should consider adjust the BMweight to a higher level. Or scan the whole</span>
0494             <span class="comment">% range of growth rate to see how it changes. (To be implemented)</span>
0495             <span class="keyword">if</span> dBMneg &gt; 0 <span class="comment">%the lower bound is indeed infeasible</span>
0496                 dBMneg = LP4fzero(grLBrecord(end - 1), LP);
0497                 dBMpos = LP4fzero(grLB, LP);
0498                 grUnstable = [grUnstable; grLB];
0499                 numInstab = true; <span class="comment">%unstable</span>
0500                 <span class="comment">%reset the bounds</span>
0501                 <span class="keyword">if</span> dBMpos &gt; 0 <span class="comment">%keep infeasible even optimizing again provided the previous lower bound basis</span>
0502                     grUB = grLB;
0503                     grLB = 0;
0504                     grCur = (grLBrecord(end - 1) + grUB) / 2;
0505                     grUBrecord(end) = grUB;
0506                     grLBrecord(end) = grLB;
0507                     <span class="comment">%loop until it becomes feasible again</span>
0508                 <span class="keyword">else</span> <span class="comment">%can indeed feasible</span>
0509                     <span class="comment">%unstable solution</span>
0510                     GRmax = grLB;
0511                     grUBrecord(end) = grUB;
0512                     grLBrecord(end) = grLB;
0513                     BMcur = BMequiv - dBMpos;
0514                     <span class="keyword">break</span>
0515                 <span class="keyword">end</span>
0516             <span class="keyword">elseif</span> dBMpos &lt; 0 <span class="comment">%the upper bound is indeed feasible</span>
0517                 GRmax = grUB;
0518                 grLB = grUB;
0519                 grUB = inf;
0520                 grUBrecord(end) = grUB;
0521                 grLBrecord(end) = grLB;
0522                 BMcur = BMequiv - dBMpos;
0523                 numInstab = true; <span class="comment">%unstable</span>
0524                 <span class="keyword">break</span>
0525             <span class="keyword">else</span>
0526                 <span class="comment">% normal situation</span>
0527                 <span class="comment">% got interval, use fzero, LP will also be dynamically updated</span>
0528                 <span class="comment">% (Users may create a modified version of fzero on their own</span>
0529                 <span class="comment">% to supply function values [dBMneg, dBMpos] for the initial</span>
0530                 <span class="comment">% points to save the time for evaluting the initial points)</span>
0531                 GRmax = fzero(@(x) LP4fzero(x, LP), [grLB, grUB], optionsf0);
0532                 <span class="comment">%the final LP may not be at GRmax</span>
0533                 dBM = LP4fzero(GRmax, LP);
0534                 BMcur = BMequiv - dBM;
0535                 <span class="keyword">break</span>
0536             <span class="keyword">end</span>
0537             
0538         <span class="keyword">elseif</span> grUB &lt;= GRtol <span class="comment">%zero growth rate</span>
0539             GRmax = 0;
0540             <span class="keyword">break</span>
0541         <span class="keyword">else</span>
0542             <span class="keyword">if</span> algorithm ~= 1 &amp;&amp; (grUB - grLB &lt; GRtol)
0543                 <span class="comment">%maximum growth rate found using an algorithm other than fzero</span>
0544                 GRmax = grLB;
0545                 LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, GRmax, GRfx, [], LP.Model.A, BMgdw);
0546                 feas = true;
0547                 <span class="keyword">try</span>
0548                     LP.solve();
0549                 <span class="keyword">catch</span> ME
0550                     <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0551                         <span class="comment">%treat as infeasible</span>
0552                         feas = false;
0553                     <span class="keyword">else</span>
0554                         disp(ME);
0555                         error(<span class="string">'Unknown error from CPLEX.'</span>);
0556                     <span class="keyword">end</span>
0557                 <span class="keyword">end</span>
0558                 <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0559                     result.stat = <span class="string">'time limit exceeded'</span>;
0560                     sol = [];
0561                     LP2 = [];
0562                     <span class="keyword">return</span>
0563                 <span class="keyword">end</span>
0564                 BMcur = 0;
0565                 dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0566                 <span class="keyword">if</span> dev &lt;= feasTol
0567                     <span class="comment">%update current biomass if successfully solved</span>
0568                     BMcur = LP.Model.obj' * LP.Solution.x;
0569                 <span class="keyword">end</span>
0570                 <span class="keyword">break</span>
0571             <span class="keyword">end</span>
0572             <span class="comment">%Get the new guess for the growth rate using simple guess or bisection</span>
0573             <span class="comment">%Simple guess</span>
0574             grNext = updateGRguess(BMcur, grCur);
0575             <span class="keyword">if</span> grNext &gt;= grUB * 0.99 || algorithm == 3 
0576                 <span class="comment">%bisection if designated or the guess is too close to the</span>
0577                 <span class="comment">%upper bound</span>
0578                 grCur = (grUB + grLB) / 2;
0579                  guessMethod = 1;
0580             <span class="keyword">elseif</span> grNext &lt;= max([grLB * 1.01, GRtol])
0581                 <span class="comment">%if the guess is too close to the lower bound</span>
0582                 <span class="keyword">if</span> ~isinf(grUB)
0583                     <span class="comment">%bisection if finite UB has been found</span>
0584                     grCur = (grUB + grLB) / 2;
0585                 <span class="keyword">else</span>
0586                     <span class="comment">% 1% larger than LB if UB not found yet</span>
0587                     grCur = grLB * 1.01;
0588                 <span class="keyword">end</span>
0589                 guessMethod = 2;
0590             <span class="keyword">elseif</span> abs(grNext - grCur) &lt; 1e-2 * grCur
0591                 <span class="comment">%When the step size is less than 1%, should be quite close to</span>
0592                 <span class="comment">%the solution but still not bounded from the</span>
0593                 <span class="comment">%other side. Use a 1% distance to get a bound</span>
0594                 <span class="keyword">if</span> grNext &gt; grCur
0595                     grCur = grCur * 1.01;
0596                 <span class="keyword">else</span>
0597                     grCur = grCur * 0.99;
0598                 <span class="keyword">end</span>
0599                 guessMethod = 3;
0600             <span class="keyword">else</span>
0601                 <span class="comment">%new guess from simple guessing</span>
0602                 grCur = grNext;
0603                 guessMethod = 0;
0604             <span class="keyword">end</span>
0605         <span class="keyword">end</span>
0606     <span class="keyword">end</span>
0607 <span class="keyword">end</span>
0608 
0609 <span class="comment">%% final correction for a feasible solution in case of numerical instability</span>
0610 <span class="comment">% In this case fzero may return a GRmax with sum(X) = 0.</span>
0611 <span class="comment">% If it happens, take a slightly smaller growth rate</span>
0612 kGRadjust = 0;
0613 <span class="keyword">while</span> ~condition2(BMcur, GRmax) &amp;&amp; GRmax &gt; GRtol &amp;&amp; kGRadjust &lt;= 10
0614     kGRadjust = kGRadjust + 1;
0615     GRmax = GRmax - GRtol / 10;
0616     LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, GRmax, GRfx, [], LP.Model.A, BMgdw);
0617     feas = true;
0618     <span class="keyword">try</span>
0619         LP.solve();
0620     <span class="keyword">catch</span> ME
0621         <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0622             <span class="comment">%treat as infeasible</span>
0623             feas = false;
0624         <span class="keyword">else</span>
0625             disp(ME);
0626             error(<span class="string">'Unknown error from CPLEX.'</span>);
0627         <span class="keyword">end</span>
0628     <span class="keyword">end</span>
0629     <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0630         result.stat = <span class="string">'time limit exceeded'</span>;
0631         sol = [];
0632         LP2 = [];
0633         <span class="keyword">return</span>
0634     <span class="keyword">end</span>
0635     <span class="comment">% check the feasibility of the solution manually</span>
0636     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0637     <span class="comment">%biomass of the current iteration</span>
0638     BMcur = 0;
0639     <span class="keyword">if</span> feas &amp;&amp; isfield(LP.Solution, <span class="string">'objval'</span>) &amp;&amp; dev &lt;= feasTol
0640         BMcur = LP.Solution.objval;
0641     <span class="keyword">end</span>
0642     <span class="keyword">if</span> verbFlag
0643         fprintf(<span class="string">'GRmax adjusment: %d\n'</span>,kGRadjust);
0644     <span class="keyword">end</span>
0645 <span class="keyword">end</span>
0646 <span class="comment">%corrected solution not feasible</span>
0647 numInstab2 = ~condition2(BMcur, GRmax) &amp;&amp; GRmax &gt; GRtol;
0648 <span class="comment">%confirm the maximum growth rate</span>
0649 result.GRmax = GRmax;
0650 <span class="keyword">if</span> ~feas
0651     result.stat = <span class="string">'infeasible'</span>;
0652     sol = [];
0653     LP2 = [];
0654     <span class="keyword">return</span>
0655 <span class="keyword">end</span>
0656 <span class="comment">%take this as the solution as it contains useful information on dual values and</span>
0657 <span class="comment">%reduced cost (e.g. to find out limiting substrate)</span>
0658 sol = LP.Solution;    
0659 
0660 <span class="comment">%add maximum biomass as a constraint to ensure</span>
0661 <span class="comment">%that the model is feasible for further analysis (e.g. FVA)</span>
0662 LP.addRows(BMcur * (1 - feasTol * 100),<span class="keyword">...</span>
0663     sparse(ones(nSp,1), (n+1):(n+nSp), ones(nSp,1), 1, size(LP.Model.A,2)),<span class="keyword">...</span>
0664     BMcur,<span class="string">'UnityBiomass'</span>);        
0665 LP.Model.obj(:) = 0;
0666 LP.Model.sense = <span class="string">'minimize'</span>;
0667 feas = true;
0668 <span class="keyword">try</span>
0669     LP.solve();
0670 <span class="keyword">catch</span> ME
0671     <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0672         <span class="comment">%treat as infeasible</span>
0673         feas = false;
0674     <span class="keyword">else</span>
0675         disp(ME);
0676         error(<span class="string">'Unknown error from CPLEX.'</span>);
0677     <span class="keyword">end</span>
0678 <span class="keyword">end</span>
0679 <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0680     result.stat = <span class="string">'time limit exceeded'</span>;
0681     sol = [];
0682     LP2 = [];
0683     <span class="keyword">return</span>
0684 <span class="keyword">end</span>
0685 dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0686 
0687 <span class="comment">%the infeasibility may increase after adding the biomass constraint (Cplex issue),</span>
0688 <span class="comment">%adjust the minimum biomass slightly until feasible</span>
0689 kBMadjust = 0;
0690 BMmaxLB = LP.Model.lhs(end);
0691 <span class="keyword">while</span> (~isfield(LP.Solution, <span class="string">'x'</span>) || dev &gt; feasTol) &amp;&amp; kBMadjust &lt; 10
0692     kBMadjust = kBMadjust + 1;
0693     LP.Model.lhs(end) = BMmaxLB * (1 - feasTol/(11 - kBMadjust));
0694     LP.solve();
0695     <span class="keyword">if</span> LP.Solution.status == 11
0696         result.stat = <span class="string">'time limit exceeded'</span>;
0697         sol = [];
0698         LP2 = [];
0699         <span class="keyword">return</span>
0700     <span class="keyword">end</span>
0701     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0702     <span class="keyword">if</span> verbFlag
0703         fprintf(<span class="string">'BMmax adjusment: %d\n'</span>,kBMadjust);
0704     <span class="keyword">end</span>
0705 <span class="keyword">end</span>
0706 <span class="comment">%solution after adding the biomass constraint becomes infeasible</span>
0707 numInstab3 = ~isfield(LP.Solution, <span class="string">'x'</span>) || dev &gt; feasTol;
0708 
0709 LP2 = [];
0710 flux = LP.Solution.x;
0711 <span class="keyword">if</span> numel(minNorm) == 1
0712     <span class="keyword">if</span> minNorm == 1
0713         <span class="keyword">if</span> verbFlag
0714             fprintf(<span class="string">'Minimizing L1-norm...\n'</span>);
0715         <span class="keyword">end</span>
0716         LP2 = Cplex(<span class="string">'minSumFlux'</span>);
0717         LP2.Model = LP.Model;
0718         LP2 = <a href="../SteadyCom/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LP2,solverParam);
0719         LP2.Start = LP.Start;
0720         LP2.Model.obj(:) = 0;
0721         LP2.addCols(ones(n,1), sparse(size(LP2.Model.A,1),n), zeros(n,1), inf(n,1));
0722         n2 = size(LP2.Model.A,2);
0723         indLP.var.vAbs = (n2-n+1):n2;
0724         LP2.addRows(-inf(n,1), sparse([1:n, 1:n], [1:n, (n2-n+1):n2], <span class="keyword">...</span>
0725             [ones(n,1); -ones(n,1)], n, n2), zeros(n,1), char(strcat(modelCom.rxns,<span class="string">'_MinSumAbs1'</span>)));
0726         indLP.con.vAbs1 = (size(LP2.Model.A,1)-n+1):size(LP2.Model.A,1);
0727         LP2.addRows(-inf(n,1), sparse([1:n, 1:n], [1:n, (n2-n+1):n2], <span class="keyword">...</span>
0728             [-ones(n,1); -ones(n,1)], n, n2), zeros(n,1), char(strcat(modelCom.rxns,<span class="string">'_MinSumAbs2'</span>)));
0729         indLP.con.vAbs2 = (size(LP2.Model.A,1)-n+1):size(LP2.Model.A,1);
0730         LP2.solve();
0731         flux = LP2.Solution.x;
0732         sol = LP2.Solution;
0733     <span class="keyword">end</span>
0734 <span class="keyword">end</span>
0735 
0736 result.vBM = flux(modelCom.indCom.spBm);
0737 result.BM = flux(n + 1 : n + nSp);
0738 <span class="comment">% result.BM(abs(result.BM) &lt; 1e-8) = 0;</span>
0739 result.Ut = flux(modelCom.indCom.EXcom(:,1));
0740 result.Ex = flux(modelCom.indCom.EXcom(:,2));
0741 result.flux = flux(1:n);
0742 result.iter = iter;
0743 <span class="keyword">if</span> result.GRmax &gt; GRtol
0744     <span class="keyword">if</span> numInstab
0745         result.stat = <span class="string">'Numerical instability (feasibility)'</span>;
0746     <span class="keyword">elseif</span> numInstab2
0747         result.stat = <span class="string">'Numerical instability (growth rate correction)'</span>;
0748     <span class="keyword">elseif</span> numInstab3
0749         result.stat = <span class="string">'Numerical instability (biomass constraint)'</span>;
0750     <span class="keyword">else</span>
0751         <span class="comment">%otherwise 'maintenance' set at the very beginning</span>
0752         result.stat = <span class="string">'optimal'</span>;
0753     <span class="keyword">end</span>
0754 <span class="keyword">end</span>
0755 <span class="keyword">if</span> pL
0756     <span class="keyword">if</span> numInstab
0757         fprintf(<span class="string">'Numerical instability for feasibility during the iterations.\n'</span>);
0758     <span class="keyword">elseif</span> numInstab2
0759         fprintf(<span class="string">'Numerical instability after final correction of growth rate.\n'</span>);
0760     <span class="keyword">elseif</span> numInstab3
0761         fprintf(<span class="string">'Numerical instability after adding the biomass constraint.\n'</span>);
0762     <span class="keyword">end</span>
0763     fprintf(<span class="string">'Maximum community growth rate: %.6f (abs. error &lt; %.1g).\tTime elapsed: %.0f sec\n'</span>, GRmax, GRtol, toc(t));
0764 <span class="keyword">end</span>
0765 
0766 <span class="keyword">if</span> ~isempty(saveModel)
0767     LP.writeModel([saveModel <span class="string">'.mps'</span>]);
0768     LP.writeBasis([saveModel <span class="string">'.bas'</span>]);
0769 <span class="keyword">end</span>
0770 
0771 <span class="keyword">end</span>
0772 
0773 <a name="_sub1" href="#_subfunctions" class="code">function [LP,index] = constructLPcom(modelCom, options, solverParam)</a>
0774 <span class="comment">%the problem matrix is structured as follows:</span>
0775 <span class="comment">%variables (column):</span>
0776 <span class="comment">%[flux (species-specific rxn) | flux (community exchange) | biomass | absolute flux for MC]</span>
0777 <span class="comment">%constraint (row):</span>
0778 <span class="comment">% [mass balance;</span>
0779 <span class="comment">%  flux bouned above by ub * biomass;</span>
0780 <span class="comment">%  flux bouned below by lb * biomass;</span>
0781 <span class="comment">%  biomass reaction = growth rate * biomass;</span>
0782 <span class="comment">%  sum(mc_j * flux_j) &lt;= biomass (molecular crowding constraint);</span>
0783 <span class="comment">%  constraint for uptake advantage]</span>
0784 
0785 <span class="comment">%% Initialization</span>
0786 <span class="comment">% get paramters</span>
0787 <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>)
0788     options = struct();
0789 <span class="keyword">end</span>
0790 <span class="keyword">if</span> ~exist(<span class="string">'solverParam'</span>, <span class="string">'var'</span>)
0791     solverParam = struct();
0792 <span class="keyword">end</span>
0793 param2get = {<span class="string">'BMcon'</span>, <span class="string">'BMrhs'</span>,<span class="string">'BMcsense'</span>, <span class="string">'BMobj'</span>, <span class="string">'BMgdw'</span>,<span class="keyword">...</span>
0794              <span class="string">'GRfx'</span>, <span class="string">'MCrhs'</span>,<span class="keyword">...</span>
0795              <span class="string">'verbFlag'</span>, <span class="string">'saveModel'</span>};
0796 eval(sprintf(<span class="string">'[%s] = getCobraComParams(param2get, options, modelCom);'</span>, <span class="keyword">...</span>
0797             strjoin(param2get, <span class="string">','</span>)<span class="keyword">...</span>
0798             )<span class="keyword">...</span>
0799     );
0800 
0801 [feasTol, optTol] = getCobraSolverParams(<span class="string">'LP'</span>,{<span class="string">'feasTol'</span>; <span class="string">'optTol'</span>}, solverParam);
0802 
0803 [m, n] = size(modelCom.S);
0804 nRxnSp = sum(modelCom.indCom.rxnSps &gt; 0); <span class="comment">%number of species-specific rxns</span>
0805 nSp = numel(modelCom.indCom.spBm); <span class="comment">%number of species</span>
0806 
0807 <span class="keyword">if</span> ~isempty(BMcon)
0808     <span class="keyword">if</span> size(BMcon,2) ~= nSp || numel(unique([size(BMcon, 1) numel(BMrhs) length(BMcsense)])) ~= 1
0809         error(<span class="string">'size of BMcon, BMrhs or BMcsense not correct.'</span>)
0810     <span class="keyword">end</span>
0811 <span class="keyword">end</span>
0812 
0813 <span class="keyword">if</span> ~isempty(BMcon)
0814     <span class="keyword">if</span> ismember(BMobj(:)', BMcon, <span class="string">'rows'</span>)
0815         warning(<span class="string">'BMobj should not be constrained. The algorithm may not converge.'</span>);
0816     <span class="keyword">end</span>
0817 <span class="keyword">end</span>
0818 
0819 <span class="comment">%% construct LP</span>
0820 <span class="comment">%create CPLEX interactive object</span>
0821 LP = Cplex(<span class="string">'maxGrCom'</span>);
0822 nVar = 0;
0823 nCon = 0;
0824 <span class="comment">%optimization sense</span>
0825 LP.Model.sense = <span class="string">'maximize'</span>;
0826 <span class="comment">%objective vector</span>
0827 obj = zeros(n + nSp, 1);
0828 <span class="comment">%sum of biomass at default</span>
0829 obj(n + 1: n + nSp) = BMobj;
0830 <span class="comment">%constraint matrix</span>
0831 A = <a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, 0, GRfx, BMcon, [], BMgdw);
0832 <span class="comment">% species-specific fluxes bounded by biomass variable but not by constant</span>
0833 lb = -inf(nRxnSp, 1);
0834 lb(modelCom.lb(1:nRxnSp)&gt;=0) = 0;
0835 lb = [lb; modelCom.lb(nRxnSp + 1: n); zeros(nSp, 1)];
0836 <span class="comment">% biomass upper bound should also be arbitrarily large, but set as 1000 here</span>
0837 ub = inf(nRxnSp, 1);
0838 ub(modelCom.ub(1:nRxnSp)&lt;=0) = 0;
0839 ub = [ub; modelCom.ub(nRxnSp + 1: n); 1000 * ones(nSp, 1)];
0840 <span class="comment">%variable type, all continuous</span>
0841 ctype = char(<span class="string">'C'</span> * ones(1, n + nSp));
0842 <span class="comment">%variable names, X for biomass</span>
0843 colname = [modelCom.rxns; strcat(<span class="string">'X_'</span>, modelCom.infoCom.spAbbr(:))];
0844 index.var.v = nVar + 1: nVar + n;
0845 index.var.x = nVar + n + 1 : nVar + n + nSp;
0846 nVar = nVar + n + nSp;
0847 
0848 <span class="comment">%handle constraint sense</span>
0849 <span class="keyword">if</span> ~isfield(modelCom, <span class="string">'csense'</span>)
0850     cs = char([<span class="string">'E'</span> * ones(1, m) <span class="string">'L'</span> * ones(1, 2 * nRxnSp) <span class="string">'E'</span> * ones(1, nSp) BMcsense(:)']);
0851 <span class="keyword">else</span> 
0852     cs = [modelCom.csense(:)' char([<span class="string">'L'</span> * ones(1, 2 * nRxnSp) <span class="string">'E'</span> * ones(1, nSp) BMcsense(:)'])];
0853 <span class="keyword">end</span>
0854 <span class="comment">%LHS, RHS for constraints</span>
0855 [rhsAdd, lhsAdd] = deal(zeros(size(A, 1), 1));
0856 rhsAdd(cs == <span class="string">'G'</span>) = inf;
0857 lhsAdd(cs == <span class="string">'L'</span>) = -inf;
0858 rhs = [modelCom.b; zeros(2 * nRxnSp + nSp, 1); BMrhs] + rhsAdd;
0859 lhs = [modelCom.b; zeros(2 * nRxnSp + nSp, 1); BMrhs] + lhsAdd;
0860 <span class="comment">%constraints' names</span>
0861 rowname = [modelCom.mets; strcat(modelCom.rxns(modelCom.indCom.rxnSps &gt; 0), <span class="string">'_ub'</span>);<span class="keyword">...</span>
0862     strcat(modelCom.rxns(modelCom.indCom.rxnSps &gt; 0), <span class="string">'_lb'</span>); <span class="keyword">...</span>
0863     strcat(<span class="string">'gr,mu,X_'</span>, modelCom.infoCom.spAbbr(:))];
0864 index.con.ub = nCon + 1 : nCon + m;
0865 nCon = nCon + m;
0866 index.con.ub = nCon + 1 : nCon + nRxnSp;
0867 nCon = nCon + nRxnSp;
0868 index.con.lb = nCon + 1 : nCon + nRxnSp;
0869 nCon = nCon + nRxnSp;
0870 index.con.gr = nCon + 1 : nCon + nSp;
0871 nCon = nCon + nSp;
0872 <span class="comment">%names for biomass constraints if any</span>
0873 <span class="keyword">if</span> ~isempty(BMcon)
0874     rowname = [rowname;strcat(<span class="string">'BMcon_'</span>,cellstr(num2str((1:size(BMcon,1))')))];
0875     index.con.bm = nCon + 1 : nCon + size(BMcon,1);
0876     nCon = nCon + size(BMcon,1);
0877 <span class="keyword">end</span>
0878 
0879 <span class="comment">%% More user-supplied constraints (optional)</span>
0880 <span class="comment">%options.MC: [n+nSp x K] matrix, for K additional constraints</span>
0881 <span class="comment">%options.MCmode: [n+nSp x K] matrix, with number 0 ~ 3</span>
0882 <span class="comment">%       0: original variable</span>
0883 <span class="comment">%       1: positive part of the variable</span>
0884 <span class="comment">%       2: negative part of the variable</span>
0885 <span class="comment">%       3: absolute value of the variable</span>
0886 <span class="comment">%options.MCrhs: right hand side of the constraints (optional, default all zeros)</span>
0887 <span class="comment">%options.MClhs: left hand side of the constraints (optional, default -inf)</span>
0888 <span class="keyword">if</span> isfield(options, <span class="string">'MC'</span>) &amp;&amp; ~isempty(options.MC)
0889     MCcont = true;
0890     <span class="comment">%Check sizes</span>
0891     <span class="keyword">if</span> isfield(options,<span class="string">'MCmode'</span>)
0892         <span class="comment">%MC and MCmode must have the same size of n+nSp x no. of constraints</span>
0893         <span class="keyword">if</span> ~isequal(size(options.MC),size(options.MCmode))
0894             <span class="keyword">if</span> ~isequal(size(options.MC),size(options.MCmode'))
0895                 warning(<span class="string">'Size of MCmode does not match that of MC. Ignore.'</span>)
0896                 MCcont = false;
0897             <span class="keyword">else</span>
0898                 MCmode = options.MCmode';
0899             <span class="keyword">end</span>
0900         <span class="keyword">else</span>
0901             MCmode = options.MCmode;
0902         <span class="keyword">end</span>
0903     <span class="keyword">else</span>
0904         MCmode = sparse(size(options.MC,1),size(options.MC,2));
0905     <span class="keyword">end</span>
0906     <span class="keyword">if</span> size(options.MC, 1) ~= n + nSp
0907         <span class="keyword">if</span> size(options.MC,2) == n + nSp
0908             options.MC = options.MC';
0909         <span class="keyword">else</span>
0910             warning(<span class="string">'Size of the crowding constraint matrix not correct. Ignore.'</span>)
0911             MCcont = false;
0912         <span class="keyword">end</span>
0913     <span class="keyword">end</span>
0914     <span class="comment">%RHS for MC constraint.</span>
0915     <span class="keyword">if</span> isfield(options,<span class="string">'MCrhs'</span>)
0916         MCrhs = options.MCrhs(:);
0917     <span class="keyword">else</span>
0918         MCrhs = zeros(size(options.MC,2),1);
0919     <span class="keyword">end</span>
0920     <span class="keyword">if</span> isfield(options,<span class="string">'MClhs'</span>)
0921         MClhs = options.MClhs(:);
0922     <span class="keyword">else</span>
0923         MClhs = -inf(size(options.MC,2),1);
0924     <span class="keyword">end</span>
0925     <span class="keyword">if</span> numel(MCrhs) == 1
0926         MCrhs = MCrhs * ones(size(options.MC,2),1);
0927     <span class="keyword">elseif</span> numel(MCrhs) ~= size(options.MC,2)
0928         warning(<span class="string">'size of MCrhs not equal to size(options.MC,2). Ignore.'</span>)
0929         MCcont = false;
0930     <span class="keyword">end</span>
0931     <span class="keyword">if</span> numel(MClhs) == 1
0932         MClhs = MClhs * ones(size(options.MC,2),1);
0933     <span class="keyword">elseif</span> numel(MClhs) ~= size(options.MC,2)
0934         warning(<span class="string">'size of MClhs not equal to size(options.MC,2). Ignore.'</span>)
0935         MCcont = false;
0936     <span class="keyword">end</span>
0937     
0938     <span class="keyword">if</span> MCcont
0939         <span class="keyword">if</span> verbFlag
0940             fprintf(<span class="string">'User-supplied constraints imposed.\n'</span>);
0941         <span class="keyword">end</span>
0942         <span class="comment">%list of fluxes requiring decomposition variables (non-zero MCmode and</span>
0943         <span class="comment">%non-zero MC)</span>
0944         <span class="comment">%first filter by lb and ub to reduce variables to be added</span>
0945         <span class="keyword">for</span> j = 1:size(MCmode,2)
0946             <span class="comment">%Ignore variables with non-negative lb but designated to use</span>
0947             <span class="comment">%negative part. Must be zero</span>
0948             options.MC(lb &gt;= 0 &amp; MCmode(:,j) == 2,j) = 0;
0949             <span class="comment">%variables with non-negative lb and designated to use positive part or</span>
0950             <span class="comment">%absolute value, simply using the original variable</span>
0951             MCmode(lb &gt;= 0 &amp; (MCmode(:,j) == 3 | MCmode(:,j) == 1),j) = 0;
0952             <span class="comment">%Ignore variables with non-positive ub but designated to use</span>
0953             <span class="comment">%positive part. Must be zero</span>
0954             options.MC(ub &lt;= 0 &amp; MCmode(:,j) == 1,j) = 0;
0955             <span class="comment">%variables with non-positive ub and designated to use negative part or</span>
0956             <span class="comment">%absolute value, simply using the negative of the original variable</span>
0957             options.MC(ub &lt;= 0 &amp; (MCmode(:,j) == 3 | MCmode(:,j) == 2),j) <span class="keyword">...</span>
0958                 = - options.MC(ub &lt;= 0 &amp; (MCmode(:,j) == 3 | MCmode(:,j) == 2),j);
0959             MCmode(ub &lt;= 0 &amp; (MCmode(:,j) == 3 | MCmode(:,j) == 2),j) = 0;
0960         <span class="keyword">end</span>
0961         Vdecomp = find(any(options.MC ~=0 &amp; MCmode ~= 0,2));
0962         nMCrow = numel(Vdecomp);
0963         <span class="comment">%record the index for each new variable and flux</span>
0964         VdecompInd = [(1:n+nSp)', sparse(repmat(Vdecomp(:),2,1),reshape(repmat(1:2,nMCrow,1),2*nMCrow,1),<span class="keyword">...</span>
0965             n+nSp+1:n+nSp+nMCrow*2,n+nSp,2)];
0966         <span class="comment">%new columns for decomposition variables</span>
0967         obj = [obj; zeros(nMCrow*2,1)];
0968         lb = [lb;zeros(nMCrow*2,1)];
0969         ub = [ub;inf(nMCrow*2,1)];
0970         colname = [colname; strcat(modelCom.rxns(Vdecomp),<span class="string">'_pos'</span>);strcat(modelCom.rxns(Vdecomp),<span class="string">'_neg'</span>)];
0971         index.var.vp = nVar + 1 : nVar + nMCrow;
0972         nVar = nVar + nMCrow;
0973         index.var.vn = nVar + 1 : nVar + nMCrow;
0974         nVar = nVar + nMCrow;
0975         ctype = [ctype char(<span class="string">'C'</span> * ones(1, nMCrow*2))];
0976         <span class="comment">%new rows to add ( 0&lt;= V - V_pos + V_neg &lt;= 0)</span>
0977         lhs = [lhs; zeros(nMCrow,1)];
0978         rhs = [rhs; zeros(nMCrow,1)];
0979         <span class="comment">%matrix to update</span>
0980         row = [1:nMCrow, 1:nMCrow, 1:nMCrow];
0981         col = [Vdecomp(:)', n+nSp+1:n+nSp+nMCrow*2];
0982         entry = [ones(1,nMCrow), -ones(1,nMCrow), ones(1,nMCrow)];
0983         A = [A sparse(size(A, 1), nMCrow*2);<span class="keyword">...</span>
0984             sparse(row, col, entry, nMCrow, n + nSp + nMCrow*2)];
0985         rowname = [rowname; strcat(modelCom.rxns(Vdecomp),<span class="string">'_decomp'</span>)];
0986         index.con.decomp = nCon + 1 : nCon + nMCrow;
0987         nCon = nCon + nMCrow;
0988         <span class="comment">%add MC constraints</span>
0989         MCmodeLogic = repmat(struct(<span class="string">'mode'</span>,[]),3,1);
0990         <span class="comment">%MCmode: 0, original flux; 1, +ve flux; 2, -ve flux; 3, absolute flux</span>
0991         <span class="comment">%original variable</span>
0992         MCmodeLogic(1).mode = MCmode == 0 &amp; options.MC ~= 0;
0993         <span class="comment">%positive part</span>
0994         MCmodeLogic(2).mode = (MCmode == 1 | MCmode == 3) &amp; options.MC ~= 0;
0995         <span class="comment">%negative part</span>
0996         MCmodeLogic(3).mode = (MCmode == 2 | MCmode == 3) &amp; options.MC ~= 0;
0997         nMCcon = 0;
0998         <span class="keyword">for</span> j = 1:3
0999             nMCcon = nMCcon + nnz(MCmodeLogic(j).mode);
1000         <span class="keyword">end</span>
1001         <span class="comment">%each original, positive or negative flux 1 entry, each absolute</span>
1002         <span class="comment">%flux 2 entires</span>
1003         [row, col, entry] = deal(zeros(nMCcon , 1));
1004         ct = 0;
1005         ct1 = 0;
1006         <span class="keyword">for</span> j = 1:size(options.MC,2)
1007             <span class="keyword">for</span> k = 1:3
1008                 <span class="comment">%add the corresponding variables into the constraint:</span>
1009                 <span class="comment">%original, positive part and negative part</span>
1010                 nJ = MCmodeLogic(k).mode(:,j);
1011                 col(ct1+1:ct1+sum(nJ)) = VdecompInd(nJ,k);
1012                 entry(ct1+1:ct1+sum(nJ)) = options.MC(nJ,j);
1013                 ct1 = ct1 + sum(nJ);
1014             <span class="keyword">end</span>
1015             row(ct+1:ct1) = j;
1016             ct = ct1;
1017         <span class="keyword">end</span>
1018         lhs = [lhs; MClhs];
1019         rhs = [rhs; MCrhs];
1020         A = [A; sparse(row, col, entry, size(options.MC,2), n + nSp + nMCrow*2)];
1021         rowname = [rowname; strcat(<span class="string">'more_con_'</span>, <span class="keyword">...</span>
1022             strtrim(cellstr(num2str((1:size(options.MC,2))'))))]; 
1023         index.con.mc = nCon + 1 : nCon + size(options.MC,2);
1024         nCon = nCon + size(options.MC,2);
1025     <span class="keyword">end</span>
1026 <span class="keyword">end</span>
1027 
1028 LP.addRows(lhs, [], rhs, char(rowname));
1029 LP.addCols(obj,A,lb,ub,[],char(colname));
1030 
1031 <span class="comment">%% Set Cplex parameters</span>
1032 <span class="comment">% set feasibility and optimality to follow the default setting in COBRA</span>
1033 LP.Param.simplex.tolerances.feasibility.Cur = feasTol;
1034 LP.Param.simplex.tolerances.optimality.Cur = optTol;
1035 <span class="comment">% set parameters given in solverParam. Will override the above two setting</span>
1036 <span class="comment">% if given in solverParam.</span>
1037 [paramList, paramPath] = <a href="#_sub3" class="code" title="subfunction [paramList, paramPath] = getParamList(param, bottomFlag)">getParamList</a>(LP.Param, 0);
1038 [paramUserList, paramUserPath] = <a href="#_sub3" class="code" title="subfunction [paramList, paramPath] = getParamList(param, bottomFlag)">getParamList</a>(solverParam, 1);
1039 paramIden = false(numel(paramUserList), 1);
1040 <span class="keyword">for</span> p = 1:numel(paramUserList)
1041     f = strcmpi(paramList,paramUserList{p});
1042     <span class="keyword">if</span> sum(f) == 1
1043         paramIden(p) = true;
1044         str = [<span class="string">'LP.Param.'</span> paramPath{f} <span class="string">'.Cur = solverParam.'</span> paramUserPath{p} <span class="string">';'</span>];
1045         eval(str);
1046     <span class="keyword">elseif</span> sum(f) &gt; 1
1047         <span class="keyword">if</span> ismember(lower(paramUserPath{p}), paramPath);
1048             paramIden(p) = true;
1049             str = [<span class="string">'LP.Param.'</span> lower(paramUserPath{p}) <span class="string">'.Cur = solverParam.'</span> paramUserPath{p} <span class="string">';'</span>];
1050             eval(str);
1051         <span class="keyword">else</span>
1052             <span class="keyword">if</span> verbFlag
1053                 fprintf(<span class="string">'solverParam.%s cannot be uniquely identified as a valid cplex parameter. Ignore.\n'</span>, paramUserPath{p});
1054             <span class="keyword">end</span>
1055         <span class="keyword">end</span>
1056     <span class="keyword">else</span>
1057         <span class="keyword">if</span> verbFlag
1058             fprintf(<span class="string">'solverParam.%s cannot be identified as a valid cplex parameter. Ignore.\n'</span>, paramUserPath{p});
1059         <span class="keyword">end</span>
1060     <span class="keyword">end</span>
1061 <span class="keyword">end</span>
1062 
1063 <span class="keyword">if</span> ~isempty(saveModel)
1064     LP.writeParam([saveModel <span class="string">'.prm'</span>]);
1065 <span class="keyword">end</span>
1066 
1067 <span class="keyword">end</span>
1068 
1069 <a name="_sub2" href="#_subfunctions" class="code">function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)</a>
1070 <span class="comment">%LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)</span>
1071 <span class="comment">% create the LP problem [LP(grCur)] given growth rate grCur and other</span>
1072 <span class="comment">% constraints if LPproblem as input does not contain the field 'A',</span>
1073 <span class="comment">% or is empty or is not inputted.</span>
1074 <span class="comment">% Otherwise, update LPproblem with the growth rate grCur. Only the</span>
1075 <span class="comment">% arguements 'modelCom', 'grCur', 'GRfx' and 'LPproblem' are used in this</span>
1076 <span class="comment">% case.</span>
1077 <span class="comment">%</span>
1078 <span class="comment">% Input:</span>
1079 <span class="comment">%   modelCom:   community model</span>
1080 <span class="comment">%   grCur:      the current growth rate for the LP to be updated to</span>
1081 <span class="comment">%   GRfx:       fixed growth rate of a certain species</span>
1082 <span class="comment">%   BMcon:      constraint matrix for species biomass</span>
1083 <span class="comment">%   LPproblem:  LP problem structure with field 'A' or the problem matrix</span>
1084 <span class="comment">%               directly</span>
1085 <span class="comment">%   BMgdw:      the gram dry weight per mmol of the biomass reaction of</span>
1086 <span class="comment">%               each species (nSp x 1 vector, default all 1)</span>
1087 <span class="comment">%</span>
1088 <span class="comment">% return a structure with the field 'A' updated if the input 'LPproblem' is</span>
1089 <span class="comment">% a structure or return a matrix if 'LPproblem' is the problem matrix</span>
1090 m = size(modelCom.S, 1);
1091 n = size(modelCom.S, 2);
1092 nRxnSp = sum(modelCom.indCom.rxnSps &gt; 0);
1093 nSp = numel(modelCom.infoCom.spAbbr);
1094 <span class="keyword">if</span> ~exist(<span class="string">'grCur'</span>, <span class="string">'var'</span>)
1095     grCur = 0;
1096 <span class="keyword">elseif</span> isempty(grCur)
1097     grCur = 0;
1098 <span class="keyword">end</span>
1099 <span class="keyword">if</span> ~exist(<span class="string">'GRfx'</span>, <span class="string">'var'</span>)|| isempty(GRfx)
1100     GRfx  = <a href="../SteadyCom/auxiliary_functions/getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>({<span class="string">'GRfx'</span>}, struct(), modelCom);
1101 <span class="keyword">end</span>
1102 <span class="keyword">if</span> ~exist(<span class="string">'LPproblem'</span>, <span class="string">'var'</span>)
1103     LPproblem = struct();
1104 <span class="keyword">end</span>
1105 
1106 construct = false;
1107 <span class="keyword">if</span> ~isstruct(LPproblem)
1108     <span class="keyword">if</span> isempty(LPproblem)
1109         construct = true;
1110     <span class="keyword">end</span>
1111 <span class="keyword">elseif</span> ~isfield(LPproblem, <span class="string">'A'</span>)
1112     construct = true;
1113 <span class="keyword">end</span>
1114 <span class="keyword">if</span> construct
1115     <span class="keyword">if</span> ~exist(<span class="string">'BMgdw'</span>, <span class="string">'var'</span>)
1116         BMgdw = ones(nSp,1);
1117     <span class="keyword">end</span>
1118     <span class="comment">%upper bound matrix</span>
1119     S_ub = sparse([1:nRxnSp 1:nRxnSp]', [(1:nRxnSp)'; n + modelCom.indCom.rxnSps(1:nRxnSp)],<span class="keyword">...</span>
1120           [ones(nRxnSp,1); -modelCom.ub(1:nRxnSp)], nRxnSp, n + nSp);
1121     <span class="comment">%lower bound matrix</span>
1122     S_lb = sparse([1:nRxnSp 1:nRxnSp]', [(1:nRxnSp)'; n + modelCom.indCom.rxnSps(1:nRxnSp)],<span class="keyword">...</span>
1123           [-ones(nRxnSp,1); modelCom.lb(1:nRxnSp)], nRxnSp, n + nSp);
1124     <span class="comment">%growth rate and biomass link matrix</span>
1125     grSp = zeros(nSp, 1);
1126     grSp(isnan(GRfx)) = grCur;
1127     <span class="comment">%given fixed growth rate</span>
1128     grSp(~isnan(GRfx)) = GRfx(~isnan(GRfx));
1129     S_gr = sparse([1:nSp 1:nSp]', [modelCom.indCom.spBm(:) (n + 1:n + nSp)'],<span class="keyword">...</span>
1130                   [BMgdw; -grSp], nSp, n + nSp);
1131     <span class="keyword">if</span> isempty(BMcon)
1132         A = [modelCom.S sparse([],[],[], m, nSp); S_ub; S_lb; S_gr];
1133     <span class="keyword">else</span>
1134         A = [modelCom.S sparse([],[],[], m, nSp); S_ub; S_lb; S_gr;<span class="keyword">...</span>
1135                    sparse([],[],[],size(BMcon, 1), n) BMcon];
1136     <span class="keyword">end</span>
1137     <span class="keyword">if</span> isstruct(LPproblem)
1138         LPproblem.A = A;
1139     <span class="keyword">else</span>
1140         LPproblem = A;
1141     <span class="keyword">end</span>
1142 <span class="keyword">else</span>
1143     <span class="keyword">for</span> j = 1:nSp
1144         <span class="keyword">if</span> isstruct(LPproblem)
1145             <span class="keyword">if</span> isnan(GRfx(j))
1146                 LPproblem.A(m + 2*nRxnSp + j, n + j) = -grCur;
1147             <span class="keyword">else</span>
1148                 LPproblem.A(m + 2*nRxnSp + j, n + j) = -GRfx(j);
1149             <span class="keyword">end</span>
1150         <span class="keyword">else</span>
1151             <span class="keyword">if</span> isnan(GRfx(j))
1152                 LPproblem(m + 2*nRxnSp + j, n + j) = -grCur;
1153             <span class="keyword">else</span>
1154                 LPproblem(m + 2*nRxnSp + j, n + j) = -GRfx(j);
1155             <span class="keyword">end</span>
1156         <span class="keyword">end</span>
1157     <span class="keyword">end</span>
1158 <span class="keyword">end</span>
1159 <span class="keyword">end</span>
1160 
1161 <a name="_sub3" href="#_subfunctions" class="code">function [paramList, paramPath] = getParamList(param, bottomFlag)</a>
1162 <span class="comment">%for matching CPLEX parameters appropriately</span>
1163 structCur = param;
1164 lv = 1;
1165 lvFieldN = zeros(10,1);
1166 lvFieldN(1) = 1;
1167 lvField = cell(10, 1);
1168 lvField{lv} = fieldnames(structCur);
1169 paramPath = {};
1170 paramList = {};
1171 <span class="keyword">while</span> lv &gt; 0
1172     <span class="keyword">if</span> isstruct(structCur.(lvField{lv}{lvFieldN(lv)}))
1173         structCur = structCur.(lvField{lv}{lvFieldN(lv)});
1174         lv = lv + 1;
1175         lvFieldN(lv) = 1;
1176         lvField{lv} = fieldnames(structCur);
1177     <span class="keyword">else</span>
1178         <span class="keyword">if</span> ~bottomFlag
1179             lv = lv - 1;
1180         <span class="keyword">end</span>
1181         <span class="keyword">if</span> lv &gt; 0
1182             c = {};
1183             <span class="keyword">for</span> j = 1:lv
1184                 c = [c lvField{j}(lvFieldN(j))];
1185             <span class="keyword">end</span>
1186             paramPath = [paramPath; strjoin(c,<span class="string">'.'</span>)];
1187             paramList = [paramList; c(end)];
1188             <span class="keyword">while</span> lvFieldN(lv) == numel(lvField{lv})
1189                 lv = lv - 1;
1190                 <span class="keyword">if</span> lv == 0
1191                     <span class="keyword">break</span>
1192                 <span class="keyword">end</span>
1193             <span class="keyword">end</span>
1194             <span class="keyword">if</span> lv &gt; 0
1195                 lvFieldN(lv) = lvFieldN(lv) + 1;
1196                 structCur = param;
1197                 <span class="keyword">for</span> j = 1:lv-1
1198                     structCur = structCur.(lvField{j}{lvFieldN(j)});
1199                 <span class="keyword">end</span>
1200             <span class="keyword">end</span>
1201         <span class="keyword">else</span>
1202             lv = 1;
1203             <span class="keyword">if</span> lvFieldN(lv) == numel(lvField{lv})
1204                 <span class="keyword">break</span>
1205             <span class="keyword">else</span>
1206                 lvFieldN(1) = lvFieldN(1) + 1;
1207             <span class="keyword">end</span>
1208         <span class="keyword">end</span>
1209     <span class="keyword">end</span>
1210 <span class="keyword">end</span>
1211 
1212 <span class="keyword">end</span>
1213 
1214 <a name="_sub4" href="#_subfunctions" class="code">function dBM = LP4fzero1(grCur, LP, modelCom, GRfx, feasTol, BMequiv,BMgdw)</a>
1215     LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, grCur, GRfx, [], LP.Model.A, BMgdw);
1216     LP.solve();
1217     <span class="keyword">if</span> LP.Solution.status == 11
1218         dBM = [];
1219         <span class="keyword">return</span>
1220     <span class="keyword">end</span>
1221     <span class="comment">% check the feasibility of the solution manually</span>
1222     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
1223     <span class="comment">%biomass of the current iteration</span>
1224     BMcur = 0;
1225     <span class="keyword">if</span> isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
1226         <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
1227             BMcur = LP.Model.obj' * LP.Solution.x;
1228         <span class="keyword">end</span>
1229     <span class="keyword">end</span>
1230     dBM = BMequiv - BMcur;
1231 <span class="keyword">end</span>
1232 
1233 <a name="_sub5" href="#_subfunctions" class="code">function dBM = LP4fzero2(grCur, LP, modelCom, GRfx, feasTol, BMequiv, GR0, BMgdw)</a>
1234     LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, grCur, GRfx, [], LP.Model.A, BMgdw);
1235     LP.solve();
1236     <span class="keyword">if</span> LP.Solution.status == 11
1237         dBM = [];
1238         <span class="keyword">return</span>
1239     <span class="keyword">end</span>
1240     <span class="comment">% check the feasibility of the solution manually</span>
1241     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
1242     <span class="comment">%biomass of the current iteration</span>
1243     BMcur = 0;
1244     <span class="keyword">if</span> isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
1245         <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
1246             BMcur = LP.Model.obj' * LP.Solution.x;
1247         <span class="keyword">end</span>
1248     <span class="keyword">end</span>
1249     dBM = (BMequiv * GR0 / grCur) - BMcur;
1250 <span class="keyword">end</span>
1251 
1252 <a name="_sub6" href="#_subfunctions" class="code">function yn = ErrBecauseInfeas(ME)</a>
1253 yn = ~isempty(strfind(lower(ME.message),<span class="string">'cplex'</span>)) &amp;&amp; <span class="keyword">...</span>
1254     ~isempty(strfind(lower(ME.message),<span class="string">'error'</span>)) &amp;&amp; <span class="keyword">...</span>
1255     ~isempty(strfind(lower(ME.message),<span class="string">'1256'</span>));
1256 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sat 06-May-2017 09:55:30 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>