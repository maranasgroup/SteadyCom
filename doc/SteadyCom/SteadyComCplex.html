<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SteadyComCplex</title>
  <meta name="keywords" content="SteadyComCplex">
  <meta name="description" content="Find the maximum community growth rate at community steady-state using SteadyCom">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html SteadyCom -->
<h1>SteadyComCplex
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Find the maximum community growth rate at community steady-state using SteadyCom</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">Find the maximum community growth rate at community steady-state using SteadyCom
Call the CPLEX dynamic object directly.

[sol, result, LP,LP2,indLP] = SteadyComCplex(modelCom,options, solverParam)

INPUT
 modelCom   community COBRA model created with crateCommModel.m 
 (the following fields are required - others can be supplied)
   S            Stoichiometric matrix
   b            Right hand side
   c            Objective coefficients
   lb           Lower bounds
   ub           Upper bounds
   infoCom      structure containing community reaction info 
                (returned along with the community model created with createCommModel) 

 options (optional)   struct with the following possible fields:
 (for constraining individual growth rates and biomass amounts, default [])
   GRfx            Fixed growth rate for species apart from the community
                   (N_species x 1 vector, NaN for unfixed growth rate,
                    or [#species | value]) e.g. to fix species 2, 3 
                   at growth rate 0.1, GRfx = [2, 0.1; 3, 0.1];
   BMcon           Biomass constraint matrix (sum(a_ij * X_j) &lt;/=/&gt; b_i)
                   (given as K x N_species matrix for K constraints)
                   e.g. [0 1 1 0] for X_2 + X_3 in a 4-species model
   BMrhs           RHS for BMcon, K x 1 vector for K constraints
   BMcsense        Sense of the constraint, 'L', 'E', 'G' for &lt;=, =, &gt;=
 (for general constraints on e.g. total carbon uptake, molecular crowding, default [])
   MC              K x (N_rxns+N_species) coefficient matrix, for K additional constraints
   MCmode          K x (N_rxns+N_species) matrix , with number 0 ~ 3
                   0: original variable
                   1: positive part of the variable
                   2: negative part of the variable
                   3: absolute value of the variable
   MCrhs           RHS of the constraints (optional, default all zeros)
   MClhs           LHS of the constraints (optional, default -inf)
 (parameters in the iterative algorithm, [default value])
   GRguess [0.2]   Initial guess of the growth rate.
   feasCrit [1]    Criteria for feasibility, 1, 2 or 3.
          The algorithm tests iteratively at a given growth rate
          whether a feasible solution can be found.
           1: Use a threshold total biomass BMweight (see below).
              i.e. sum(X) &gt;= BMweight
              (use it if the total biomass is known)
           2: Use a threshold on minimum biomass production
              (=specific growth rate x sum(biomass), which is roughly 
              constant over a range of growth rate if the sum of biomass 
              is not bounded above) 
              i.e. sum(X) * gr &gt;= BMtol * BMref * GR0
              where BMref is the maximum biomass at a small growth rate GR0
              and BMtol is a fraction ranging from 0 to 1
   algorithm [1]   algorithm to find the maximum growth rate
           1. Fzero after finding grLB and grUB with simple guessing [gr' = gr * sum(X)/sum(X')]
           2. Simple guessing with minimum one percent step size
           3. Bisection method
   BMweight [1]    Minimum total biomass for feasibility. Used only if feasCrit = 1
                   Set BMweight to a close-to-zero value to compute the
                   wash-out dilution rate.
   GR0 [0.001]     A small growth rate to obtain a reference value for
                   maximum total biomass production. 
                   Used only if feasCrit = 2 or solveGR0 = true
   BMtol [0.8]     Fractional tolerance for biomass production to check
                   feasibility. Used only if feasCrit = 2
   solveGR0[false] true to first solve the model at a low growth rate GR0
   GRtol [1e-6]    Precision for the growth rate found (grUB - grLB &lt; GRtol)
   BMtolAbs [1e-5] Absolute tolerance for positivity of biomass
   maxIter (1e3)   maximum nummber of iteration
 (parameters in the optimization model, [default value])
   minNorm [0]     0: No minNorm. 1: min sum of absolution flux of the final solution.
   BMgdw [all 1s]  The gram dry weight per mmol of the biomass reaction of
                   each organism. Maybe used to scale the biomass reactions between species.
   BMobj [all 1s]  Objective coefficient for the biomass of each species
                   when doing the maximization at each step. Maybe used to
                   scale the biomass reactions between species.
 (other parameters)
   verbFlag  [3]   Print level
                   0, 1, 2, 3 for silence, one log per 10, 5 (default) or 1
                   iteration respectively
   LPonly [false]  Return the initial LP at zero growth rate only. Calculate nothing.
   saveModel ['']  String, if non-empty, save the cplex model, basis and parameters.

 solverParam       Cplex parameter structure. E.g., struct('simplex',struct('tolerances',struct('feasibility',1e-8)))

OUTPUT
 sol: cplex solution structure
 result: structure with the following fields:
   GRmax:          maximum specific growth rate found (/h)
   vBM:            biomass formation rate (gdw/h)
   BM:             Biomass vector at GRmax (gdw)
   Ut:             uptake fluxes (mmol/h)
   Ex:             export fluxes (mmol/h)
   flux:           flux distribution for the original model
   (the following 'iter' fields are status in each iteration:)
   [GR | biomass X | biomass flux (GR * X) | max. infeas. of solution])
   iter0:          stationary, no growth, gr = 0
   iter1:          small growth rate, gr = GR0
   iterPre:        iterations for finding upper and lower bounds
   iter:           iterations for finding max gr using bisectional method
   stat:           status at the termination of the algorithm
                   infeasible: infeasible model, even with maintenance
                               requirement only
                   maintenance:feasible at maintenance, but cannot grow
                   optimal:    optimal growth rate found</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>	Check the feasibility of a solution given a COBRA model structure or a CPLEX dynamic object and a solution</li><li><a href="../SteadyCom/auxiliary_functions/getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>	get the required default parameters</li><li><a href="../SteadyCom/auxiliary_functions/infoCom2indCom.html" class="code" title="function indCom = infoCom2indCom(modelCom,infoCom,revFlag,spAbbr,spName)">infoCom2indCom</a>	Transform between community reaction IDs and reaction names</li><li><a href="../SteadyCom/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>	Set the parameters of the CPLEX object according to the structure solverParam</li><li><a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>	Create and update the SteadyCom LP model in CPLEX format.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="SteadyComFVACplex.html" class="code" title="function [minFlux,maxFlux,minFD,maxFD, GRvector, result,LP] = SteadyComFVACplex(modelCom,options,solverParam)">SteadyComFVACplex</a>	Flux variability analysis for community model at community steady-state for a range of growth rates.</li><li><a href="SteadyComPOACplex.html" class="code" title="function [POAtable, fluxRange, Stat, GRvector] = SteadyComPOACplex(modelCom,options,solverParam)">SteadyComPOACplex</a>	Pairwise POA for community model at community steady-state for a range of growth rates</li><li><a href="../SteadyCom/auxiliary_functions/SteadyComFVAgrCplex.html" class="code" title="function [minFlux,maxFlux,minFD,maxFD,LP,GR] = SteadyComFVAgrCplex(modelCom,options,solverParam,LP)">SteadyComFVAgrCplex</a>	Flux variability analysis for community model at community steady-state at a given growth rate.</li><li><a href="../SteadyCom/auxiliary_functions/SteadyComPOAgrCplex.html" class="code" title="function [POAtable, fluxRange, Stat, pairList] = SteadyComPOAgrCplex(modelCom,options,solverParam,LP)">SteadyComPOAgrCplex</a>	Pairwise POA for community model at community steady-state at a given growth rate</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [LP,index] = constructLPcom(modelCom, options, solverParam)</a></li><li><a href="#_sub2" class="code">function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)</a></li><li><a href="#_sub3" class="code">function [paramList, paramPath] = getParamList(param, bottomFlag)</a></li><li><a href="#_sub4" class="code">function dBM = LP4fzero1(grCur, LP, modelCom, GRfx, feasTol, BMequiv,BMgdw)</a></li><li><a href="#_sub5" class="code">function dBM = LP4fzero2(grCur, LP, modelCom, GRfx, feasTol, BMequiv, GR0, BMgdw)</a></li><li><a href="#_sub6" class="code">function yn = ErrBecauseInfeas(ME)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [sol, result, LP, LP2,indLP] = SteadyComCplex(modelCom,options, solverParam,LP)</a>
0002 <span class="comment">%Find the maximum community growth rate at community steady-state using SteadyCom</span>
0003 <span class="comment">%Call the CPLEX dynamic object directly.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%[sol, result, LP,LP2,indLP] = SteadyComCplex(modelCom,options, solverParam)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%INPUT</span>
0008 <span class="comment">% modelCom   community COBRA model created with crateCommModel.m</span>
0009 <span class="comment">% (the following fields are required - others can be supplied)</span>
0010 <span class="comment">%   S            Stoichiometric matrix</span>
0011 <span class="comment">%   b            Right hand side</span>
0012 <span class="comment">%   c            Objective coefficients</span>
0013 <span class="comment">%   lb           Lower bounds</span>
0014 <span class="comment">%   ub           Upper bounds</span>
0015 <span class="comment">%   infoCom      structure containing community reaction info</span>
0016 <span class="comment">%                (returned along with the community model created with createCommModel)</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% options (optional)   struct with the following possible fields:</span>
0019 <span class="comment">% (for constraining individual growth rates and biomass amounts, default [])</span>
0020 <span class="comment">%   GRfx            Fixed growth rate for species apart from the community</span>
0021 <span class="comment">%                   (N_species x 1 vector, NaN for unfixed growth rate,</span>
0022 <span class="comment">%                    or [#species | value]) e.g. to fix species 2, 3</span>
0023 <span class="comment">%                   at growth rate 0.1, GRfx = [2, 0.1; 3, 0.1];</span>
0024 <span class="comment">%   BMcon           Biomass constraint matrix (sum(a_ij * X_j) &lt;/=/&gt; b_i)</span>
0025 <span class="comment">%                   (given as K x N_species matrix for K constraints)</span>
0026 <span class="comment">%                   e.g. [0 1 1 0] for X_2 + X_3 in a 4-species model</span>
0027 <span class="comment">%   BMrhs           RHS for BMcon, K x 1 vector for K constraints</span>
0028 <span class="comment">%   BMcsense        Sense of the constraint, 'L', 'E', 'G' for &lt;=, =, &gt;=</span>
0029 <span class="comment">% (for general constraints on e.g. total carbon uptake, molecular crowding, default [])</span>
0030 <span class="comment">%   MC              K x (N_rxns+N_species) coefficient matrix, for K additional constraints</span>
0031 <span class="comment">%   MCmode          K x (N_rxns+N_species) matrix , with number 0 ~ 3</span>
0032 <span class="comment">%                   0: original variable</span>
0033 <span class="comment">%                   1: positive part of the variable</span>
0034 <span class="comment">%                   2: negative part of the variable</span>
0035 <span class="comment">%                   3: absolute value of the variable</span>
0036 <span class="comment">%   MCrhs           RHS of the constraints (optional, default all zeros)</span>
0037 <span class="comment">%   MClhs           LHS of the constraints (optional, default -inf)</span>
0038 <span class="comment">% (parameters in the iterative algorithm, [default value])</span>
0039 <span class="comment">%   GRguess [0.2]   Initial guess of the growth rate.</span>
0040 <span class="comment">%   feasCrit [1]    Criteria for feasibility, 1, 2 or 3.</span>
0041 <span class="comment">%          The algorithm tests iteratively at a given growth rate</span>
0042 <span class="comment">%          whether a feasible solution can be found.</span>
0043 <span class="comment">%           1: Use a threshold total biomass BMweight (see below).</span>
0044 <span class="comment">%              i.e. sum(X) &gt;= BMweight</span>
0045 <span class="comment">%              (use it if the total biomass is known)</span>
0046 <span class="comment">%           2: Use a threshold on minimum biomass production</span>
0047 <span class="comment">%              (=specific growth rate x sum(biomass), which is roughly</span>
0048 <span class="comment">%              constant over a range of growth rate if the sum of biomass</span>
0049 <span class="comment">%              is not bounded above)</span>
0050 <span class="comment">%              i.e. sum(X) * gr &gt;= BMtol * BMref * GR0</span>
0051 <span class="comment">%              where BMref is the maximum biomass at a small growth rate GR0</span>
0052 <span class="comment">%              and BMtol is a fraction ranging from 0 to 1</span>
0053 <span class="comment">%   algorithm [1]   algorithm to find the maximum growth rate</span>
0054 <span class="comment">%           1. Fzero after finding grLB and grUB with simple guessing [gr' = gr * sum(X)/sum(X')]</span>
0055 <span class="comment">%           2. Simple guessing with minimum one percent step size</span>
0056 <span class="comment">%           3. Bisection method</span>
0057 <span class="comment">%   BMweight [1]    Minimum total biomass for feasibility. Used only if feasCrit = 1</span>
0058 <span class="comment">%                   Set BMweight to a close-to-zero value to compute the</span>
0059 <span class="comment">%                   wash-out dilution rate.</span>
0060 <span class="comment">%   GR0 [0.001]     A small growth rate to obtain a reference value for</span>
0061 <span class="comment">%                   maximum total biomass production.</span>
0062 <span class="comment">%                   Used only if feasCrit = 2 or solveGR0 = true</span>
0063 <span class="comment">%   BMtol [0.8]     Fractional tolerance for biomass production to check</span>
0064 <span class="comment">%                   feasibility. Used only if feasCrit = 2</span>
0065 <span class="comment">%   solveGR0[false] true to first solve the model at a low growth rate GR0</span>
0066 <span class="comment">%   GRtol [1e-6]    Precision for the growth rate found (grUB - grLB &lt; GRtol)</span>
0067 <span class="comment">%   BMtolAbs [1e-5] Absolute tolerance for positivity of biomass</span>
0068 <span class="comment">%   maxIter (1e3)   maximum nummber of iteration</span>
0069 <span class="comment">% (parameters in the optimization model, [default value])</span>
0070 <span class="comment">%   minNorm [0]     0: No minNorm. 1: min sum of absolution flux of the final solution.</span>
0071 <span class="comment">%   BMgdw [all 1s]  The gram dry weight per mmol of the biomass reaction of</span>
0072 <span class="comment">%                   each organism. Maybe used to scale the biomass reactions between species.</span>
0073 <span class="comment">%   BMobj [all 1s]  Objective coefficient for the biomass of each species</span>
0074 <span class="comment">%                   when doing the maximization at each step. Maybe used to</span>
0075 <span class="comment">%                   scale the biomass reactions between species.</span>
0076 <span class="comment">% (other parameters)</span>
0077 <span class="comment">%   verbFlag  [3]   Print level</span>
0078 <span class="comment">%                   0, 1, 2, 3 for silence, one log per 10, 5 (default) or 1</span>
0079 <span class="comment">%                   iteration respectively</span>
0080 <span class="comment">%   LPonly [false]  Return the initial LP at zero growth rate only. Calculate nothing.</span>
0081 <span class="comment">%   saveModel ['']  String, if non-empty, save the cplex model, basis and parameters.</span>
0082 <span class="comment">%</span>
0083 <span class="comment">% solverParam       Cplex parameter structure. E.g., struct('simplex',struct('tolerances',struct('feasibility',1e-8)))</span>
0084 <span class="comment">%</span>
0085 <span class="comment">%OUTPUT</span>
0086 <span class="comment">% sol: cplex solution structure</span>
0087 <span class="comment">% result: structure with the following fields:</span>
0088 <span class="comment">%   GRmax:          maximum specific growth rate found (/h)</span>
0089 <span class="comment">%   vBM:            biomass formation rate (gdw/h)</span>
0090 <span class="comment">%   BM:             Biomass vector at GRmax (gdw)</span>
0091 <span class="comment">%   Ut:             uptake fluxes (mmol/h)</span>
0092 <span class="comment">%   Ex:             export fluxes (mmol/h)</span>
0093 <span class="comment">%   flux:           flux distribution for the original model</span>
0094 <span class="comment">%   (the following 'iter' fields are status in each iteration:)</span>
0095 <span class="comment">%   [GR | biomass X | biomass flux (GR * X) | max. infeas. of solution])</span>
0096 <span class="comment">%   iter0:          stationary, no growth, gr = 0</span>
0097 <span class="comment">%   iter1:          small growth rate, gr = GR0</span>
0098 <span class="comment">%   iterPre:        iterations for finding upper and lower bounds</span>
0099 <span class="comment">%   iter:           iterations for finding max gr using bisectional method</span>
0100 <span class="comment">%   stat:           status at the termination of the algorithm</span>
0101 <span class="comment">%                   infeasible: infeasible model, even with maintenance</span>
0102 <span class="comment">%                               requirement only</span>
0103 <span class="comment">%                   maintenance:feasible at maintenance, but cannot grow</span>
0104 <span class="comment">%                   optimal:    optimal growth rate found</span>
0105 <span class="comment">%</span>
0106 <span class="comment">%</span>
0107 t = tic;
0108 t0 = 0;
0109 <span class="comment">%% Initialization</span>
0110 <span class="comment">%check required fields for community model</span>
0111 <span class="keyword">if</span> ~isfield(modelCom,<span class="string">'infoCom'</span>) || ~isstruct(modelCom.infoCom) || <span class="keyword">...</span>
0112         ~all(isfield(modelCom.infoCom,{<span class="string">'spBm'</span>,<span class="string">'EXcom'</span>,<span class="string">'EXsp'</span>,<span class="string">'spAbbr'</span>,<span class="string">'rxnSps'</span>,<span class="string">'metSps'</span>}))
0113     error(<span class="string">'infoCom must be provided for calculating the max. community growth rate.\n'</span>);
0114 <span class="keyword">end</span>
0115 <span class="comment">%get useful reaction indices</span>
0116 modelCom.indCom = <a href="../SteadyCom/auxiliary_functions/infoCom2indCom.html" class="code" title="function indCom = infoCom2indCom(modelCom,infoCom,revFlag,spAbbr,spName)">infoCom2indCom</a>(modelCom);
0117 
0118 <span class="comment">%get paramters</span>
0119 <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>)
0120     options = struct();
0121 <span class="keyword">end</span>
0122 <span class="keyword">if</span> ~exist(<span class="string">'solverParam'</span>, <span class="string">'var'</span>) || isempty(solverParam)
0123     <span class="comment">%default Cplex parameters</span>
0124     solverParam = <a href="../SteadyCom/auxiliary_functions/getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>(<span class="string">'CplexParam'</span>);
0125 <span class="keyword">end</span>
0126 param2get = {<span class="string">'GRguess'</span>, <span class="string">'GR0'</span>, <span class="string">'GRfx'</span>, <span class="string">'GRtol'</span>, <span class="string">'solveGR0'</span>,<span class="keyword">...</span>
0127              <span class="string">'BMweight'</span>, <span class="string">'BMtol'</span>, <span class="string">'BMtolAbs'</span>, <span class="string">'BMgdw'</span>,<span class="keyword">...</span>
0128              <span class="string">'feasCrit'</span>, <span class="string">'maxIter'</span>, <span class="string">'verbFlag'</span>, <span class="string">'algorithm'</span>,<span class="keyword">...</span>
0129              <span class="string">'minNorm'</span>, <span class="string">'LPonly'</span>, <span class="string">'saveModel'</span>};
0130 eval(sprintf(<span class="string">'[%s] = getCobraComParams(param2get, options, modelCom);'</span>, <span class="keyword">...</span>
0131             strjoin(param2get, <span class="string">','</span>)<span class="keyword">...</span>
0132             )<span class="keyword">...</span>
0133     );
0134 <span class="comment">%print level</span>
0135 pL = [0 10 5 1];
0136 pL = pL(verbFlag + 1);
0137 
0138 [m, n] = size(modelCom.S); <span class="comment">%model size</span>
0139 nRxnSp = sum(modelCom.indCom.rxnSps &gt; 0); <span class="comment">%number of organism-specific rxns</span>
0140 nSp = numel(modelCom.indCom.spBm); <span class="comment">%number of organism</span>
0141 
0142 <span class="keyword">if</span> verbFlag &amp;&amp; ~LPonly
0143     fprintf(<span class="string">'Find maximum community growth rate..\n'</span>);
0144 <span class="keyword">end</span>
0145 <span class="comment">%% Construct LP</span>
0146 
0147 <span class="keyword">if</span> nargin &lt; 4
0148     <span class="comment">%create the CPLEX LP problem if not given</span>
0149     [LP,indLP] = <a href="#_sub1" class="code" title="subfunction [LP,index] = constructLPcom(modelCom, options, solverParam)">constructLPcom</a>(modelCom, options, solverParam);
0150 <span class="keyword">else</span>
0151     <span class="comment">% LP given: delete the row constraining the sum of biomass if exist</span>
0152     f = find(strcmp(cellstr(LP.Model.rowname),<span class="string">'UnityBiomass'</span>));
0153     <span class="keyword">if</span> ~isempty(f)
0154         LP.delRows(f);
0155     <span class="keyword">end</span>
0156     LP.Model.obj(n+1:n+nSp) = 1;
0157     LP.Model.sense = <span class="string">'maximize'</span>;
0158     indLP = [];
0159 <span class="keyword">end</span>
0160 <span class="comment">% Make sure the feasibility tolerance used in CPLEX and in the main loop</span>
0161 <span class="comment">% are the same ('constructLPcom' has already reconciled the two tolerances)</span>
0162 feasTol = LP.Param.simplex.tolerances.feasibility.Cur;
0163 LP2 = [];
0164 <span class="comment">% terminate if only the LP structure is called as output</span>
0165 <span class="keyword">if</span> LPonly
0166     result = struct();
0167     [result.GRmax, result.vBM, result.BM, result.Ut, result.Ex, <span class="keyword">...</span>
0168         result.flux, result.iter, result.iter0, sol] = deal([]);
0169     result.stat = <span class="string">'LPonly'</span>;
0170     <span class="keyword">return</span>
0171 <span class="keyword">end</span>
0172 
0173 <span class="comment">%counter for iteration</span>
0174 k = 0;
0175 iter = [];
0176 
0177 <span class="comment">% if LP is supplied by user, directly jump to the main loop</span>
0178 <span class="keyword">if</span> nargin &lt; 4
0179     <span class="comment">%% Test the ability of the model to stay at maintenance only.</span>
0180     
0181     <span class="comment">%solve for maintenance (zero growth)</span>
0182     <span class="comment">%This step usually costs very little time. Worth doing to confirm</span>
0183     <span class="comment">%feasibility</span>
0184     feas = true;
0185     <span class="keyword">try</span>
0186         LP.solve();
0187     <span class="keyword">catch</span> ME
0188         <span class="comment">%possible internal error of cplex</span>
0189         <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0190             <span class="comment">%treat as infeasible</span>
0191             feas = false;
0192         <span class="keyword">else</span>
0193             disp(ME);
0194             error(<span class="string">'Unknown error from CPLEX.'</span>);
0195         <span class="keyword">end</span>
0196     <span class="keyword">end</span>
0197         
0198     <span class="comment">% check the feasibility of the solution manually</span>
0199     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0200 
0201     result = struct();
0202     [result.GRmax, result.vBM, result.BM, result.Ut, result.Ex, result.flux, <span class="keyword">...</span>
0203         result.iter0, result.iter, result.stat] = deal([]);
0204     <span class="comment">%terminate if time limit has been exceeded.</span>
0205     <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0206         result.stat = <span class="string">'time limit exceeded'</span>;
0207         sol = [];
0208         <span class="keyword">return</span>
0209     <span class="keyword">end</span>
0210     <span class="comment">%biomass at zero growth rate</span>
0211     BM0 = 0;
0212     <span class="keyword">if</span> feas &amp;&amp; isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
0213         <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
0214             <span class="comment">%if feasible</span>
0215             BM0 = LP.Model.obj' * LP.Solution.x;
0216         <span class="keyword">end</span>
0217     <span class="keyword">end</span>
0218     <span class="keyword">if</span> BM0 &lt; BMtolAbs
0219         <span class="comment">%if no biomass is formed, infeasible. Terminate.</span>
0220         <span class="keyword">if</span> verbFlag
0221             t0 = toc(t);
0222             fprintf(<span class="string">'Model infeasible at maintenance. Time elapsed: %.0f / %.0f sec\n'</span>, t0, t0);
0223         <span class="keyword">end</span>
0224         sol = [];
0225         result.stat = <span class="string">'infeasible'</span>;
0226         LP2 = [];
0227         <span class="keyword">return</span>
0228     <span class="keyword">else</span>
0229         <span class="comment">%record the current result if feasible</span>
0230         <span class="keyword">if</span> verbFlag
0231             t0 = toc(t);
0232             fprintf(<span class="string">'Model feasible at maintenance. Time elapsed: %.0f / %.0f sec\n'</span>, t0, t0);
0233         <span class="keyword">end</span>
0234         sol = LP.Solution;
0235         <span class="keyword">if</span> ~isempty(saveModel)
0236             LP.writeBasis([saveModel <span class="string">'.bas'</span>]);
0237         <span class="keyword">end</span>
0238         result.GRmax = 0;
0239         result.vBM = LP.Solution.x(modelCom.indCom.spBm);
0240         result.BM = LP.Solution.x(n + 1 : n + nSp);
0241         result.BM(abs(result.BM) &lt; 1e-8) = 0;
0242         result.Ut = LP.Solution.x(modelCom.indCom.EXcom(:,1));
0243         result.Ex = LP.Solution.x(modelCom.indCom.EXcom(:,2));
0244         result.flux = LP.Solution.x(1:n);
0245         result.iter0 = [0 BM0 0 dev];
0246         result.iter = [];
0247         result.stat = <span class="string">'maintenance'</span>;
0248     <span class="keyword">end</span>
0249 
0250     <span class="comment">%% Test at very small growth rate to see if the model is able to grow</span>
0251     <span class="comment">% only if using the reference biomass at GR0 to define maximum growth rate</span>
0252     <span class="keyword">if</span> feasCrit == 2 || solveGR0
0253         <span class="comment">%update the growth rate</span>
0254         LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, GR0, GRfx, [], LP.Model.A, BMgdw);
0255         feas = true;
0256         <span class="keyword">try</span>
0257             LP.solve();
0258         <span class="keyword">catch</span> ME
0259             <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0260                 <span class="comment">%treat as infeasible</span>
0261                 feas = false;
0262             <span class="keyword">else</span>
0263                 disp(ME);
0264                 error(<span class="string">'Unknown error from CPLEX.'</span>);
0265             <span class="keyword">end</span>
0266         <span class="keyword">end</span>
0267         <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0268             result.stat = <span class="string">'time limit exceeded'</span>;
0269             sol = [];
0270             LP2 = [];
0271             <span class="keyword">return</span>
0272         <span class="keyword">end</span>
0273         <span class="comment">% check the feasibility of the solution manually</span>
0274         dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0275         <span class="comment">%biomass for reference (at a very low growth rate)</span>
0276         BMref = 0;
0277         <span class="keyword">if</span> feas &amp;&amp; isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
0278             <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
0279                 BMref = LP.Model.obj' * LP.Solution.x;
0280             <span class="keyword">end</span>
0281         <span class="keyword">end</span>
0282 
0283         iter = [iter; 0 GR0 BMref GR0 * BMref dev 0];
0284         <span class="keyword">if</span> BMref &lt; BMtolAbs
0285             <span class="comment">%if no biomass can be formed, the model can only stay at maintenance.</span>
0286             <span class="keyword">if</span> verbFlag
0287                 t1 = toc(t);
0288                 fprintf(<span class="string">'Model infeasible at a minimal growth rate (%.6f). Time elapsed: %.0f / %.0f sec\n.'</span>, GR0, t1 - t0, t1);
0289             <span class="keyword">end</span>
0290             result.iter = iter;
0291             <span class="keyword">return</span>
0292         <span class="keyword">else</span>
0293             <span class="comment">%able to grow. Compute bounds</span>
0294             <span class="keyword">if</span> verbFlag
0295                 t1 = toc(t);
0296                 fprintf(<span class="string">'Model feasible at a minimal growth (%.6f). Time elapsed: %.0f / %.0f sec.\nLook for upper and lower bounds...\n'</span>, GR0, t1 - t0, t1);
0297                 t0 = t1;
0298             <span class="keyword">end</span>
0299             sol = LP.Solution;
0300             <span class="keyword">if</span> ~isempty(saveModel)
0301                 LP.writeBasis([saveModel <span class="string">'.bas'</span>]);
0302             <span class="keyword">end</span>
0303             result.GRmax = GR0;
0304             result.vBM = LP.Solution.x(modelCom.indCom.spBm);
0305             result.BM = LP.Solution.x(n + 1 : n + nSp);
0306             result.BM(abs(result.BM) &lt; 1e-8) = 0;
0307             result.Ut = LP.Solution.x(modelCom.indCom.EXcom(:,1));
0308             result.Ex = LP.Solution.x(modelCom.indCom.EXcom(:,2));
0309             result.flux = LP.Solution.x(1:n);
0310             result.stat = <span class="string">'minimal growth'</span>;
0311         <span class="keyword">end</span>
0312     <span class="keyword">end</span>
0313     <span class="comment">%initial growth rate</span>
0314     grCur = GRguess(1);
0315 <span class="keyword">else</span>
0316     <span class="comment">% if LP is given, assume it has a starting basis for the growth rate</span>
0317     <span class="comment">% encoded in the problem. Start from there should give quick</span>
0318     <span class="comment">% convergence</span>
0319     jSpGrCur = find(isnan(GRfx),1);
0320     <span class="comment">%initial growth rate</span>
0321     grCur = full(abs(LP.Model.A(m + 2*nRxnSp + jSpGrCur, n + jSpGrCur)));
0322 <span class="keyword">end</span>
0323 
0324 <span class="comment">%% main loop to solve for maximum growth rate</span>
0325 
0326 <span class="comment">%feasibility criteria</span>
0327 <span class="keyword">switch</span> feasCrit
0328     <span class="comment">%condition1 for determining the feasibility of the current growth rate</span>
0329     <span class="comment">%condition2 for ensuring the final feasibility after the max growth</span>
0330     <span class="comment">%rate is found</span>
0331     <span class="keyword">case</span> 1
0332         <span class="comment">%maximum growth rate given a fixed total community biomass, defaulted to be 1</span>
0333         BMequiv = BMweight;
0334         condition1 = @(BMcur, grCur) BMcur &gt;= BMweight;
0335         condition2 = @(BMcur, grCur) BMcur &gt;= BMweight * (1 - BMtolAbs);
0336         <span class="comment">%guess for grCur</span>
0337         updateGRguess = @(BMcur, grCur) grCur * BMcur / BMweight;
0338         LP4fzero = @(grCur, LP)<span class="keyword">...</span>
0339             <a href="#_sub4" class="code" title="subfunction dBM = LP4fzero1(grCur, LP, modelCom, GRfx, feasTol, BMequiv,BMgdw)">LP4fzero1</a>(grCur, LP, modelCom, GRfx, feasTol, BMequiv, BMgdw);
0340     <span class="keyword">case</span> 2
0341         <span class="comment">%maximum growth rate with production rate of community biomass not</span>
0342         <span class="comment">%less than the reference value at growth rate GR0</span>
0343         BMequiv = BMtol * BMref;
0344         condition1 = @(BMcur, grCur) BMcur * grCur &gt;= BMtol * BMref * GR0;
0345         condition2 = @(BMcur, grCur) BMcur * grCur &gt;= BMtol * BMref * GR0 * (1 - BMtolAbs);
0346         <span class="comment">%guess for grCur</span>
0347         updateGRguess = @(BMcur, grCur) grCur * BMcur / (BMtol * BMref * GR0);
0348         LP4fzero = @(grCur, LP)<span class="keyword">...</span>
0349             <a href="#_sub5" class="code" title="subfunction dBM = LP4fzero2(grCur, LP, modelCom, GRfx, feasTol, BMequiv, GR0, BMgdw)">LP4fzero2</a>(grCur, LP, modelCom, GRfx, feasTol, BMequiv, GR0, BMgdw);
0350 <span class="keyword">end</span>
0351 
0352 grLB = 0;<span class="comment">%lower bound for growth rate</span>
0353 grUB = Inf;<span class="comment">%upper bound for growth rate</span>
0354 grLBrecord = grLB;<span class="comment">%vector recording all intermediate grLB</span>
0355 grUBrecord = grUB;<span class="comment">%vector recording all intermediate grUB</span>
0356 guessMethod = 0; <span class="comment">%guess used for updating the growth rate</span>
0357 numInstab = false; <span class="comment">%flag for numerical instability</span>
0358 grUnstable = []; <span class="comment">%growth rate at which numerical instability occurs</span>
0359 optionsf0 = optimset; <span class="comment">%matlab optimization parameters</span>
0360 <span class="keyword">switch</span> pL
0361     <span class="keyword">case</span> 0
0362         optionsf0.Display = <span class="string">'off'</span>;
0363     <span class="keyword">case</span> 10
0364         optionsf0.Display = <span class="string">'final'</span>;
0365     <span class="keyword">case</span> 5
0366         optionsf0.Display = <span class="string">'notify'</span>;
0367     <span class="keyword">case</span> 1
0368         optionsf0.Display = <span class="string">'iter'</span>;
0369 <span class="keyword">end</span>
0370 optionsf0.MaxIter = maxIter; <span class="comment">%max. number of iteration</span>
0371 optionsf0.TolX = GRtol; <span class="comment">%tolerance for the root found</span>
0372 <span class="comment">% optionsf0.TolFun = BMtolAbs;</span>
0373 
0374 <span class="comment">%Finding an interval for the max. growth rate using the simple guess</span>
0375 <span class="comment">%growth rate x max(biomass) = constant</span>
0376 <span class="comment">%apparently better than guess by matlab fzero</span>
0377 <span class="comment">%Then initiate fzero or continue using simple guess or bisection depending</span>
0378 <span class="comment">%on the parameter 'algorithm'</span>
0379 col1disp = num2str(max([log10(maxIter)+1,4]));
0380 <span class="keyword">if</span> pL
0381     fprintf([<span class="string">'%'</span> col1disp <span class="string">'s  %8s  %8s  %8s  Time elapsed (iteration/total)\n'</span>],<span class="keyword">...</span>
0382         <span class="string">'Iter'</span>,<span class="string">'LB'</span>,<span class="string">'To test'</span>, <span class="string">'UB'</span>);
0383 <span class="keyword">end</span>
0384 <span class="keyword">if</span> 0
0385     <span class="comment">%totally solved by fzero (unused)</span>
0386     GRmax = fzero(@(x) LP4fzero(x, LP), grCur, optionsf0);
0387 <span class="keyword">else</span>
0388     k1LB = false; <span class="comment">%lower bound found at k = 1</span>
0389     <span class="comment">%If an LB is found at k = 1, kLU counts the number of LBs found.</span>
0390     <span class="comment">%If an UB is found at k = 1, kLU counts the number of UBs found.</span>
0391     kLU = 0; 
0392     <span class="keyword">while</span> true
0393         <span class="comment">%solve for initial guess</span>
0394         k = k + 1;
0395         <span class="keyword">if</span> mod(k, pL) == 0
0396             t1 = toc(t);
0397             <span class="keyword">if</span> ~numInstab
0398                 fprintf([<span class="string">'%'</span> col1disp <span class="string">'d  %8.6f  %8.6f  %8.6f  %.0f / %.0f sec\n'</span>],<span class="keyword">...</span>
0399                     k, grLB, grCur, grUB, t1 - t0, t1);
0400             <span class="keyword">else</span>
0401                 fprintf([<span class="string">'%'</span> col1disp <span class="string">'d  %8.6f  %8.6f  %8.6f  %.0f / %.0f sec (numerical instability)\n'</span>],<span class="keyword">...</span>
0402                     k, grLB, grCur, grUB, t1 - t0, t1);
0403                 numInstab = false;
0404             <span class="keyword">end</span>
0405             <span class="comment">%fprintf('%.0f\t%.6f\t%.6f\tTime elapsed: %.0f / %.0f sec\n', k, grLB, grUB, t1 - t0, t1);</span>
0406             t0 = t1;
0407         <span class="keyword">end</span>
0408         <span class="comment">%update growth rate</span>
0409         LP.Model.A = <a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, grCur, GRfx, [], LP.Model.A, BMgdw);
0410         feas = true;
0411         <span class="keyword">try</span>
0412             LP.solve();
0413         <span class="keyword">catch</span> ME
0414             <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0415                 <span class="comment">%treat as infeasible</span>
0416                 feas = false;
0417             <span class="keyword">else</span>
0418                 disp(ME);
0419                 error(<span class="string">'Unknown error from CPLEX.'</span>);
0420             <span class="keyword">end</span>
0421         <span class="keyword">end</span>
0422         <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0423             result.stat = <span class="string">'time limit exceeded'</span>;
0424             sol = [];
0425             LP2 = [];
0426             <span class="keyword">return</span>
0427         <span class="keyword">end</span>
0428         <span class="comment">% check the feasibility of the solution manually</span>
0429         dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0430         <span class="comment">%get biomass of the current iteration</span>
0431         BMcur = 0;
0432         <span class="keyword">if</span> feas &amp;&amp; isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
0433             <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
0434                 <span class="comment">%update the current biomass if successfully solved</span>
0435                 BMcur = LP.Model.obj' * LP.Solution.x;
0436             <span class="keyword">end</span>
0437             <span class="keyword">if</span> condition1(BMcur, grCur)
0438                 <span class="comment">%feasible at the current growth rate (sum(X) &gt;= X_0)</span>
0439                 grLB = grCur; <span class="comment">%an LB is found</span>
0440                 grLBrecord = [grLBrecord; grLB];
0441                 <span class="keyword">if</span> k == 1
0442                     k1LB = true;
0443                 <span class="keyword">end</span>
0444                 kLU = kLU + k1LB;
0445             <span class="keyword">else</span>
0446                 <span class="comment">%infeasible at the current growth rate (sum(X) &lt; X_0)</span>
0447                 grUB = grCur; <span class="comment">%an UB is found</span>
0448                 grUBrecord = [grUBrecord; grUB];
0449                 <span class="keyword">if</span> k == 1
0450                     k1LB = false;
0451                 <span class="keyword">end</span>
0452                 kLU = kLU + ~k1LB; 
0453             <span class="keyword">end</span>
0454         <span class="keyword">else</span>
0455             <span class="comment">%No solution</span>
0456             <span class="comment">%(can become infeasible because of numerical instability)</span>
0457             grUB = grCur;
0458             grUBrecord = [grUBrecord; grUB];
0459             <span class="keyword">if</span> k == 1
0460                 k1LB = false;
0461             <span class="keyword">end</span>
0462             kLU = kLU + ~k1LB;
0463         <span class="keyword">end</span>
0464         <span class="comment">%record results for the current iteration</span>
0465         iter = [iter; k, grCur, BMcur, grCur * BMcur, dev, guessMethod];    
0466         
0467         <span class="comment">% condition for switching to fzero or concluding GRmax = 0:</span>
0468         <span class="comment">%   kLU &gt;= 2 to ensure neither of the bounds is the initial guess.</span>
0469         <span class="comment">% Algorithm:</span>
0470         <span class="comment">%   1. Fzero after finding LB and UB by simple guessing [gr' = gr * sum(X)/sum(X')]</span>
0471         <span class="comment">%   2. Simple guessing with minimum one percent step size</span>
0472         <span class="comment">%   3. Bisection method</span>
0473         <span class="keyword">if</span> (grLB &gt; 0 &amp;&amp; grUB &lt; Inf &amp;&amp; kLU &gt;= 2 &amp;&amp; algorithm == 1)
0474             <span class="comment">%switch to fzero</span>
0475             dBMneg = LP4fzero(grLB, LP);<span class="comment">%expected to be -ve</span>
0476             dBMpos = LP4fzero(grUB, LP);<span class="comment">%expected to be +ve</span>
0477             <span class="keyword">if</span> isempty(dBMneg) || isempty(dBMpos)
0478                 result.stat = <span class="string">'time limit exceeded'</span>;
0479                 sol = [];
0480                 LP2 = [];
0481                 <span class="keyword">return</span>
0482             <span class="keyword">end</span>
0483             <span class="comment">%Check for numerical instability.</span>
0484             <span class="comment">% Can happens when the model is bounded such that the maximum growth rate</span>
0485             <span class="comment">% for the given biomass is close to the critical wash-out dilution rate</span>
0486             <span class="comment">% of the system. In this case, the maximum biomass sum(X) can drop very</span>
0487             <span class="comment">% abruptly with sum(X) ~ 0 at GRmax but sum(X) &gt;&gt; BMequiv at GRmax - eps.</span>
0488             <span class="comment">% Feasibility in this range returned by the solver is not trustworthy.</span>
0489             <span class="comment">% Should consider adjust the BMweight to a higher level. Or scan the whole</span>
0490             <span class="comment">% range of growth rate to see how it changes. (To be implemented)</span>
0491             <span class="keyword">if</span> dBMneg &gt; 0 <span class="comment">%the lower bound is indeed infeasible</span>
0492                 dBMneg = LP4fzero(grLBrecord(end - 1), LP);
0493                 dBMpos = LP4fzero(grLB, LP);
0494                 grUnstable = [grUnstable; grLB];
0495                 numInstab = true;
0496                 <span class="comment">%reset the bounds</span>
0497                 <span class="keyword">if</span> dBMpos &gt; 0 <span class="comment">%keep infeasible even optimizing again provided the previous lower bound basis</span>
0498                     grUB = grLB;
0499                     grLB = 0;
0500                     grCur = (grLBrecord(end - 1) + grUB) / 2;
0501                     grUBrecord(end) = grUB;
0502                     grLBrecord(end) = grLB;
0503                     <span class="comment">%loop until it becomes feasible again</span>
0504                 <span class="keyword">else</span> <span class="comment">%can indeed feasible</span>
0505                     <span class="comment">%unstable solution</span>
0506                     GRmax = grLB;
0507                     grUBrecord(end) = grUB;
0508                     grLBrecord(end) = grLB;
0509                     BMcur = BMequiv - dBMpos;
0510                     <span class="keyword">break</span>
0511                 <span class="keyword">end</span>
0512             <span class="keyword">elseif</span> dBMpos &lt; 0 <span class="comment">%the upper bound is indeed feasible</span>
0513                 GRmax = grUB;
0514                 grLB = grUB;
0515                 grUB = inf;
0516                 grUBrecord(end) = grUB;
0517                 grLBrecord(end) = grLB;
0518                 BMcur = BMequiv - dBMpos;
0519                 numInstab = true;
0520                 <span class="keyword">break</span>
0521             <span class="keyword">else</span>
0522                 <span class="comment">% normal situation</span>
0523                 <span class="comment">% got interval, use fzero, LP will also be dynamically updated</span>
0524                 <span class="comment">% (Users may create a modified version of fzero on their own</span>
0525                 <span class="comment">% to supply function values [dBMneg, dBMpos] for the initial</span>
0526                 <span class="comment">% points to save the time for evaluting the initial points)</span>
0527                 GRmax = fzero(@(x) LP4fzero(x, LP), [grLB, grUB], optionsf0);
0528                 <span class="comment">%the final LP may not be at GRmax</span>
0529                 dBM = LP4fzero(GRmax, LP);
0530                 BMcur = BMequiv - dBM;
0531                 <span class="keyword">break</span>
0532             <span class="keyword">end</span>
0533             
0534         <span class="keyword">elseif</span> grUB &lt;= GRtol <span class="comment">%zero growth rate</span>
0535             GRmax = 0;
0536             <span class="keyword">break</span>
0537         <span class="keyword">else</span>
0538             <span class="keyword">if</span> algorithm ~= 1 &amp;&amp; (grUB - grLB &lt; GRtol)
0539                 <span class="comment">%maximum growth rate found using an algorithm other than fzero</span>
0540                 GRmax = grLB;
0541                 LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, GRmax, GRfx, [], LP.Model.A, BMgdw);
0542                 feas = true;
0543                 <span class="keyword">try</span>
0544                     LP.solve();
0545                 <span class="keyword">catch</span> ME
0546                     <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0547                         <span class="comment">%treat as infeasible</span>
0548                         feas = false;
0549                     <span class="keyword">else</span>
0550                         disp(ME);
0551                         error(<span class="string">'Unknown error from CPLEX.'</span>);
0552                     <span class="keyword">end</span>
0553                 <span class="keyword">end</span>
0554                 <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0555                     result.stat = <span class="string">'time limit exceeded'</span>;
0556                     sol = [];
0557                     LP2 = [];
0558                     <span class="keyword">return</span>
0559                 <span class="keyword">end</span>
0560                 BMcur = 0;
0561                 dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0562                 <span class="keyword">if</span> dev &lt;= feasTol
0563                     <span class="comment">%update current biomass if successfully solved</span>
0564                     BMcur = LP.Model.obj' * LP.Solution.x;
0565                 <span class="keyword">end</span>
0566                 <span class="keyword">break</span>
0567             <span class="keyword">end</span>
0568             <span class="comment">%Get the new guess for the growth rate using simple guess or bisection</span>
0569             <span class="comment">%Simple guess</span>
0570             grNext = updateGRguess(BMcur, grCur);
0571             <span class="keyword">if</span> grNext &gt;= grUB * 0.99 || algorithm == 3 
0572                 <span class="comment">%bisection if designated or the guess is too close to the</span>
0573                 <span class="comment">%upper bound</span>
0574                 grCur = (grUB + grLB) / 2;
0575                  guessMethod = 1;
0576             <span class="keyword">elseif</span> grNext &lt;= max([grLB * 1.01, GRtol])
0577                 <span class="comment">%if the guess is too close to the lower bound</span>
0578                 <span class="keyword">if</span> ~isinf(grUB)
0579                     <span class="comment">%bisection if finite UB has been found</span>
0580                     grCur = (grUB + grLB) / 2;
0581                 <span class="keyword">else</span>
0582                     <span class="comment">% 1% larger than LB if UB not found yet</span>
0583                     grCur = grLB * 1.01;
0584                 <span class="keyword">end</span>
0585                 guessMethod = 2;
0586             <span class="keyword">elseif</span> abs(grNext - grCur) &lt; 1e-2 * grCur
0587                 <span class="comment">%When the step size is less than 1%, should be quite close to</span>
0588                 <span class="comment">%the solution but still not bounded from the</span>
0589                 <span class="comment">%other side. Use a 1% distance to get a bound</span>
0590                 <span class="keyword">if</span> grNext &gt; grCur
0591                     grCur = grCur * 1.01;
0592                 <span class="keyword">else</span>
0593                     grCur = grCur * 0.99;
0594                 <span class="keyword">end</span>
0595                 guessMethod = 3;
0596             <span class="keyword">else</span>
0597                 <span class="comment">%new guess from simple guessing</span>
0598                 grCur = grNext;
0599                 guessMethod = 0;
0600             <span class="keyword">end</span>
0601         <span class="keyword">end</span>
0602     <span class="keyword">end</span>
0603 <span class="keyword">end</span>
0604 
0605 <span class="comment">%% final correction for a feasible solution in case of numerical instability</span>
0606 <span class="comment">% In this case fzero may return a GRmax with sum(X) = 0.</span>
0607 <span class="comment">% If it happens, take a slightly smaller growth rate</span>
0608 kGRadjust = 0;
0609 <span class="keyword">while</span> ~condition2(BMcur, GRmax) &amp;&amp; GRmax &gt; GRtol &amp;&amp; kGRadjust &lt;= 10
0610     kGRadjust = kGRadjust + 1;
0611     GRmax = GRmax - GRtol / 10;
0612     LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, GRmax, GRfx, [], LP.Model.A, BMgdw);
0613     feas = true;
0614     <span class="keyword">try</span>
0615         LP.solve();
0616     <span class="keyword">catch</span> ME
0617         <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0618             <span class="comment">%treat as infeasible</span>
0619             feas = false;
0620         <span class="keyword">else</span>
0621             disp(ME);
0622             error(<span class="string">'Unknown error from CPLEX.'</span>);
0623         <span class="keyword">end</span>
0624     <span class="keyword">end</span>
0625     <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0626         result.stat = <span class="string">'time limit exceeded'</span>;
0627         sol = [];
0628         LP2 = [];
0629         <span class="keyword">return</span>
0630     <span class="keyword">end</span>
0631     <span class="comment">% check the feasibility of the solution manually</span>
0632     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0633     <span class="comment">%biomass of the current iteration</span>
0634     BMcur = 0;
0635     <span class="keyword">if</span> feas &amp;&amp; isfield(LP.Solution, <span class="string">'objval'</span>) &amp;&amp; dev &lt;= feasTol
0636         BMcur = LP.Solution.objval;
0637     <span class="keyword">end</span>
0638     <span class="keyword">if</span> verbFlag
0639         fprintf(<span class="string">'GRmax adjusment: %d\n'</span>,kGRadjust);
0640     <span class="keyword">end</span>
0641 <span class="keyword">end</span>
0642 numInstab2 = ~condition2(BMcur, GRmax) &amp;&amp; GRmax &gt; GRtol;
0643 <span class="comment">%confirm the maximum growth rate</span>
0644 result.GRmax = GRmax;
0645 <span class="keyword">if</span> ~feas
0646     result.stat = <span class="string">'infeasible'</span>;
0647     sol = [];
0648     LP2 = [];
0649     <span class="keyword">return</span>
0650 <span class="keyword">end</span>
0651 <span class="comment">%take this as the solution as it contains useful information on dual values and</span>
0652 <span class="comment">%reduced cost (e.g. to find out limiting substrate)</span>
0653 sol = LP.Solution;    
0654 
0655 <span class="comment">%add maximum biomass as a constraint to ensure</span>
0656 <span class="comment">%that the model is feasible for further analysis (e.g. FVA)</span>
0657 LP.addRows(BMcur * (1 - feasTol * 100),<span class="keyword">...</span>
0658     sparse(ones(nSp,1), (n+1):(n+nSp), ones(nSp,1), 1, size(LP.Model.A,2)),<span class="keyword">...</span>
0659     BMcur,<span class="string">'UnityBiomass'</span>);        
0660 LP.Model.obj(:) = 0;
0661 LP.Model.sense = <span class="string">'minimize'</span>;
0662 feas = true;
0663 <span class="keyword">try</span>
0664     LP.solve();
0665 <span class="keyword">catch</span> ME
0666     <span class="keyword">if</span> <a href="#_sub6" class="code" title="subfunction yn = ErrBecauseInfeas(ME)">ErrBecauseInfeas</a>(ME)
0667         <span class="comment">%treat as infeasible</span>
0668         feas = false;
0669     <span class="keyword">else</span>
0670         disp(ME);
0671         error(<span class="string">'Unknown error from CPLEX.'</span>);
0672     <span class="keyword">end</span>
0673 <span class="keyword">end</span>
0674 <span class="keyword">if</span> feas &amp;&amp; LP.Solution.status == 11
0675     result.stat = <span class="string">'time limit exceeded'</span>;
0676     sol = [];
0677     LP2 = [];
0678     <span class="keyword">return</span>
0679 <span class="keyword">end</span>
0680 dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0681 
0682 <span class="comment">%the infeasibility may increase after adding the biomass constraint (Cplex issue),</span>
0683 <span class="comment">%adjust the minimum biomass slightly until feasible</span>
0684 kBMadjust = 0;
0685 BMmaxLB = LP.Model.lhs(end);
0686 <span class="keyword">while</span> (~isfield(LP.Solution, <span class="string">'x'</span>) || dev &gt; feasTol) &amp;&amp; kBMadjust &lt; 10
0687     kBMadjust = kBMadjust + 1;
0688     LP.Model.lhs(end) = BMmaxLB * (1 - feasTol/(11 - kBMadjust));
0689     LP.solve();
0690     <span class="keyword">if</span> LP.Solution.status == 11
0691         result.stat = <span class="string">'time limit exceeded'</span>;
0692         sol = [];
0693         LP2 = [];
0694         <span class="keyword">return</span>
0695     <span class="keyword">end</span>
0696     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0697     <span class="keyword">if</span> verbFlag
0698         fprintf(<span class="string">'BMmax adjusment: %d\n'</span>,kBMadjust);
0699     <span class="keyword">end</span>
0700 <span class="keyword">end</span>
0701 numInstab3 = ~isfield(LP.Solution, <span class="string">'x'</span>) || dev &gt; feasTol;
0702 
0703 LP2 = [];
0704 flux = LP.Solution.x;
0705 <span class="keyword">if</span> numel(minNorm) == 1
0706     <span class="keyword">if</span> minNorm == 1
0707         <span class="keyword">if</span> verbFlag
0708             fprintf(<span class="string">'Minimizing L1-norm...\n'</span>);
0709         <span class="keyword">end</span>
0710         LP2 = Cplex(<span class="string">'minSumFlux'</span>);
0711         LP2.Model = LP.Model;
0712         LP2 = <a href="../SteadyCom/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LP2,solverParam);
0713         LP2.Start = LP.Start;
0714         LP2.Model.obj(:) = 0;
0715         LP2.addCols(ones(n,1), sparse(size(LP2.Model.A,1),n), zeros(n,1), inf(n,1));
0716         n2 = size(LP2.Model.A,2);
0717         indLP.var.vAbs = (n2-n+1):n2;
0718         LP2.addRows(-inf(n,1), sparse([1:n, 1:n], [1:n, (n2-n+1):n2], <span class="keyword">...</span>
0719             [ones(n,1); -ones(n,1)], n, n2), zeros(n,1), char(strcat(modelCom.rxns,<span class="string">'_MinSumAbs1'</span>)));
0720         indLP.con.vAbs1 = (size(LP2.Model.A,1)-n+1):size(LP2.Model.A,1);
0721         LP2.addRows(-inf(n,1), sparse([1:n, 1:n], [1:n, (n2-n+1):n2], <span class="keyword">...</span>
0722             [-ones(n,1); -ones(n,1)], n, n2), zeros(n,1), char(strcat(modelCom.rxns,<span class="string">'_MinSumAbs2'</span>)));
0723         indLP.con.vAbs2 = (size(LP2.Model.A,1)-n+1):size(LP2.Model.A,1);
0724         LP2.solve();
0725         flux = LP2.Solution.x;
0726         sol = LP2.Solution;
0727     <span class="keyword">end</span>
0728 <span class="keyword">end</span>
0729 
0730 result.vBM = flux(modelCom.indCom.spBm);
0731 result.BM = flux(n + 1 : n + nSp);
0732 <span class="comment">% result.BM(abs(result.BM) &lt; 1e-8) = 0;</span>
0733 result.Ut = flux(modelCom.indCom.EXcom(:,1));
0734 result.Ex = flux(modelCom.indCom.EXcom(:,2));
0735 result.flux = flux(1:n);
0736 result.iter = iter;
0737 <span class="keyword">if</span> result.GRmax &gt; GRtol
0738     <span class="keyword">if</span> numInstab
0739         result.stat = <span class="string">'Numerical instability 1'</span>;
0740     <span class="keyword">elseif</span> numInstab2
0741         result.stat = <span class="string">'Numerical instability 2'</span>;
0742     <span class="keyword">elseif</span> numInstab3
0743         result.stat = <span class="string">'Numerical instability 3'</span>;
0744     <span class="keyword">else</span>
0745         <span class="comment">%otherwise 'maintenance' set at the very beginning</span>
0746         result.stat = <span class="string">'optimal'</span>;
0747     <span class="keyword">end</span>
0748 <span class="keyword">end</span>
0749 <span class="keyword">if</span> pL
0750     <span class="keyword">if</span> numInstab
0751         fprintf(<span class="string">'Numerical instability for feasibility occurs.\n'</span>);
0752     <span class="keyword">elseif</span> numInstab2
0753         fprintf(<span class="string">'Numerical instability during final correction of growth rate occurs.\n'</span>);
0754     <span class="keyword">elseif</span> numInstab3
0755         fprintf(<span class="string">'Numerical instability during final correction of biomass occurs.\n'</span>);
0756     <span class="keyword">end</span>
0757     fprintf(<span class="string">'Maximum community growth rate: %.6f (abs. error &lt; %.1g).\tTime elapsed: %.0f sec\n'</span>, GRmax, GRtol, toc(t));
0758 <span class="keyword">end</span>
0759 
0760 <span class="keyword">if</span> ~isempty(saveModel)
0761     LP.writeModel([saveModel <span class="string">'.mps'</span>]);
0762     LP.writeBasis([saveModel <span class="string">'.bas'</span>]);
0763 <span class="keyword">end</span>
0764 
0765 <span class="keyword">end</span>
0766 
0767 <a name="_sub1" href="#_subfunctions" class="code">function [LP,index] = constructLPcom(modelCom, options, solverParam)</a>
0768 <span class="comment">%the problem matrix is structured as follows:</span>
0769 <span class="comment">%variables (column):</span>
0770 <span class="comment">%[flux (species-specific rxn) | flux (community exchange) | biomass | absolute flux for MC]</span>
0771 <span class="comment">%constraint (row):</span>
0772 <span class="comment">% [mass balance;</span>
0773 <span class="comment">%  flux bouned above by ub * biomass;</span>
0774 <span class="comment">%  flux bouned below by lb * biomass;</span>
0775 <span class="comment">%  biomass reaction = growth rate * biomass;</span>
0776 <span class="comment">%  sum(mc_j * flux_j) &lt;= biomass (molecular crowding constraint);</span>
0777 <span class="comment">%  constraint for uptake advantage]</span>
0778 
0779 <span class="comment">%% Initialization</span>
0780 <span class="comment">% get paramters</span>
0781 <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>)
0782     options = struct();
0783 <span class="keyword">end</span>
0784 <span class="keyword">if</span> ~exist(<span class="string">'solverParam'</span>, <span class="string">'var'</span>)
0785     solverParam = struct();
0786 <span class="keyword">end</span>
0787 param2get = {<span class="string">'BMcon'</span>, <span class="string">'BMrhs'</span>,<span class="string">'BMcsense'</span>, <span class="string">'BMobj'</span>, <span class="string">'BMgdw'</span>,<span class="keyword">...</span>
0788              <span class="string">'GRfx'</span>, <span class="string">'MCrhs'</span>,<span class="keyword">...</span>
0789              <span class="string">'verbFlag'</span>, <span class="string">'saveModel'</span>};
0790 eval(sprintf(<span class="string">'[%s] = getCobraComParams(param2get, options, modelCom);'</span>, <span class="keyword">...</span>
0791             strjoin(param2get, <span class="string">','</span>)<span class="keyword">...</span>
0792             )<span class="keyword">...</span>
0793     );
0794 
0795 [feasTol, optTol] = getCobraSolverParams(<span class="string">'LP'</span>,{<span class="string">'feasTol'</span>; <span class="string">'optTol'</span>}, solverParam);
0796 
0797 [m, n] = size(modelCom.S);
0798 nRxnSp = sum(modelCom.indCom.rxnSps &gt; 0); <span class="comment">%number of species-specific rxns</span>
0799 nSp = numel(modelCom.indCom.spBm); <span class="comment">%number of species</span>
0800 
0801 <span class="keyword">if</span> ~isempty(BMcon)
0802     <span class="keyword">if</span> size(BMcon,2) ~= nSp || numel(unique([size(BMcon, 1) numel(BMrhs) length(BMcsense)])) ~= 1
0803         error(<span class="string">'size of BMcon, BMrhs or BMcsense not correct.'</span>)
0804     <span class="keyword">end</span>
0805 <span class="keyword">end</span>
0806 
0807 <span class="keyword">if</span> ~isempty(BMcon)
0808     <span class="keyword">if</span> ismember(BMobj(:)', BMcon, <span class="string">'rows'</span>)
0809         warning(<span class="string">'BMobj should not be constrained. The algorithm may not converge.'</span>);
0810     <span class="keyword">end</span>
0811 <span class="keyword">end</span>
0812 
0813 <span class="comment">%% construct LP</span>
0814 <span class="comment">%create CPLEX interactive object</span>
0815 LP = Cplex(<span class="string">'maxGrCom'</span>);
0816 nVar = 0;
0817 nCon = 0;
0818 <span class="comment">%optimization sense</span>
0819 LP.Model.sense = <span class="string">'maximize'</span>;
0820 <span class="comment">%objective vector</span>
0821 obj = zeros(n + nSp, 1);
0822 <span class="comment">%sum of biomass at default</span>
0823 obj(n + 1: n + nSp) = BMobj;
0824 <span class="comment">%constraint matrix</span>
0825 A = <a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, 0, GRfx, BMcon, [], BMgdw);
0826 <span class="comment">% species-specific fluxes bounded by biomass variable but not by constant</span>
0827 lb = -inf(nRxnSp, 1);
0828 lb(modelCom.lb(1:nRxnSp)&gt;=0) = 0;
0829 lb = [lb; modelCom.lb(nRxnSp + 1: n); zeros(nSp, 1)];
0830 <span class="comment">% biomass upper bound should also be arbitrarily large, but set as 1000 here</span>
0831 ub = inf(nRxnSp, 1);
0832 ub(modelCom.ub(1:nRxnSp)&lt;=0) = 0;
0833 ub = [ub; modelCom.ub(nRxnSp + 1: n); 1000 * ones(nSp, 1)];
0834 <span class="comment">%variable type, all continuous</span>
0835 ctype = char(<span class="string">'C'</span> * ones(1, n + nSp));
0836 <span class="comment">%variable names, X for biomass</span>
0837 colname = [modelCom.rxns; strcat(<span class="string">'X_'</span>, modelCom.infoCom.spAbbr(:))];
0838 index.var.v = nVar + 1: nVar + n;
0839 index.var.x = nVar + n + 1 : nVar + n + nSp;
0840 nVar = nVar + n + nSp;
0841 
0842 <span class="comment">%handle constraint sense</span>
0843 <span class="keyword">if</span> ~isfield(modelCom, <span class="string">'csense'</span>)
0844     cs = char([<span class="string">'E'</span> * ones(1, m) <span class="string">'L'</span> * ones(1, 2 * nRxnSp) <span class="string">'E'</span> * ones(1, nSp) BMcsense(:)']);
0845 <span class="keyword">else</span> 
0846     cs = [modelCom.csense(:)' char([<span class="string">'L'</span> * ones(1, 2 * nRxnSp) <span class="string">'E'</span> * ones(1, nSp) BMcsense(:)'])];
0847 <span class="keyword">end</span>
0848 <span class="comment">%LHS, RHS for constraints</span>
0849 [rhsAdd, lhsAdd] = deal(zeros(size(A, 1), 1));
0850 rhsAdd(cs == <span class="string">'G'</span>) = inf;
0851 lhsAdd(cs == <span class="string">'L'</span>) = -inf;
0852 rhs = [modelCom.b; zeros(2 * nRxnSp + nSp, 1); BMrhs] + rhsAdd;
0853 lhs = [modelCom.b; zeros(2 * nRxnSp + nSp, 1); BMrhs] + lhsAdd;
0854 <span class="comment">%constraints' names</span>
0855 rowname = [modelCom.mets; strcat(modelCom.rxns(modelCom.indCom.rxnSps &gt; 0), <span class="string">'_ub'</span>);<span class="keyword">...</span>
0856     strcat(modelCom.rxns(modelCom.indCom.rxnSps &gt; 0), <span class="string">'_lb'</span>); <span class="keyword">...</span>
0857     strcat(<span class="string">'gr,mu,X_'</span>, modelCom.infoCom.spAbbr(:))];
0858 index.con.ub = nCon + 1 : nCon + m;
0859 nCon = nCon + m;
0860 index.con.ub = nCon + 1 : nCon + nRxnSp;
0861 nCon = nCon + nRxnSp;
0862 index.con.lb = nCon + 1 : nCon + nRxnSp;
0863 nCon = nCon + nRxnSp;
0864 index.con.gr = nCon + 1 : nCon + nSp;
0865 nCon = nCon + nSp;
0866 <span class="comment">%names for biomass constraints if any</span>
0867 <span class="keyword">if</span> ~isempty(BMcon)
0868     rowname = [rowname;strcat(<span class="string">'BMcon_'</span>,cellstr(num2str((1:size(BMcon,1))')))];
0869     index.con.bm = nCon + 1 : nCon + size(BMcon,1);
0870     nCon = nCon + size(BMcon,1);
0871 <span class="keyword">end</span>
0872 
0873 <span class="comment">%% More user-supplied constraints (optional)</span>
0874 <span class="comment">%options.MC: [n+nSp x K] matrix, for K additional constraints</span>
0875 <span class="comment">%options.MCmode: [n+nSp x K] matrix, with number 0 ~ 3</span>
0876 <span class="comment">%       0: original variable</span>
0877 <span class="comment">%       1: positive part of the variable</span>
0878 <span class="comment">%       2: negative part of the variable</span>
0879 <span class="comment">%       3: absolute value of the variable</span>
0880 <span class="comment">%options.MCrhs: right hand side of the constraints (optional, default all zeros)</span>
0881 <span class="comment">%options.MClhs: left hand side of the constraints (optional, default -inf)</span>
0882 <span class="keyword">if</span> isfield(options, <span class="string">'MC'</span>) &amp;&amp; ~isempty(options.MC)
0883     MCcont = true;
0884     <span class="comment">%Check sizes</span>
0885     <span class="keyword">if</span> isfield(options,<span class="string">'MCmode'</span>)
0886         <span class="comment">%MC and MCmode must have the same size of n+nSp x no. of constraints</span>
0887         <span class="keyword">if</span> ~isequal(size(options.MC),size(options.MCmode))
0888             <span class="keyword">if</span> ~isequal(size(options.MC),size(options.MCmode'))
0889                 warning(<span class="string">'Size of MCmode does not match that of MC. Ignore.'</span>)
0890                 MCcont = false;
0891             <span class="keyword">else</span>
0892                 MCmode = options.MCmode';
0893             <span class="keyword">end</span>
0894         <span class="keyword">else</span>
0895             MCmode = options.MCmode;
0896         <span class="keyword">end</span>
0897     <span class="keyword">else</span>
0898         MCmode = sparse(size(options.MC,1),size(options.MC,2));
0899     <span class="keyword">end</span>
0900     <span class="keyword">if</span> size(options.MC, 1) ~= n + nSp
0901         <span class="keyword">if</span> size(options.MC,2) == n + nSp
0902             options.MC = options.MC';
0903         <span class="keyword">else</span>
0904             warning(<span class="string">'Size of the crowding constraint matrix not correct. Ignore.'</span>)
0905             MCcont = false;
0906         <span class="keyword">end</span>
0907     <span class="keyword">end</span>
0908     <span class="comment">%RHS for MC constraint.</span>
0909     <span class="keyword">if</span> isfield(options,<span class="string">'MCrhs'</span>)
0910         MCrhs = options.MCrhs(:);
0911     <span class="keyword">else</span>
0912         MCrhs = zeros(size(options.MC,2),1);
0913     <span class="keyword">end</span>
0914     <span class="keyword">if</span> isfield(options,<span class="string">'MClhs'</span>)
0915         MClhs = options.MClhs(:);
0916     <span class="keyword">else</span>
0917         MClhs = -inf(size(options.MC,2),1);
0918     <span class="keyword">end</span>
0919     <span class="keyword">if</span> numel(MCrhs) == 1
0920         MCrhs = MCrhs * ones(size(options.MC,2),1);
0921     <span class="keyword">elseif</span> numel(MCrhs) ~= size(options.MC,2)
0922         warning(<span class="string">'size of MCrhs not equal to size(options.MC,2). Ignore.'</span>)
0923         MCcont = false;
0924     <span class="keyword">end</span>
0925     <span class="keyword">if</span> numel(MClhs) == 1
0926         MClhs = MClhs * ones(size(options.MC,2),1);
0927     <span class="keyword">elseif</span> numel(MClhs) ~= size(options.MC,2)
0928         warning(<span class="string">'size of MClhs not equal to size(options.MC,2). Ignore.'</span>)
0929         MCcont = false;
0930     <span class="keyword">end</span>
0931     
0932     <span class="keyword">if</span> MCcont
0933         <span class="keyword">if</span> verbFlag
0934             fprintf(<span class="string">'User-supplied constraints imposed.\n'</span>);
0935         <span class="keyword">end</span>
0936         <span class="comment">%list of fluxes requiring decomposition variables (non-zero MCmode and</span>
0937         <span class="comment">%non-zero MC)</span>
0938         <span class="comment">%first filter by lb and ub to reduce variables to be added</span>
0939         <span class="keyword">for</span> j = 1:size(MCmode,2)
0940             <span class="comment">%Ignore variables with non-negative lb but designated to use</span>
0941             <span class="comment">%negative part. Must be zero</span>
0942             options.MC(lb &gt;= 0 &amp; MCmode(:,j) == 2,j) = 0;
0943             <span class="comment">%variables with non-negative lb and designated to use positive part or</span>
0944             <span class="comment">%absolute value, simply using the original variable</span>
0945             MCmode(lb &gt;= 0 &amp; (MCmode(:,j) == 3 | MCmode(:,j) == 1),j) = 0;
0946             <span class="comment">%Ignore variables with non-positive ub but designated to use</span>
0947             <span class="comment">%positive part. Must be zero</span>
0948             options.MC(ub &lt;= 0 &amp; MCmode(:,j) == 1,j) = 0;
0949             <span class="comment">%variables with non-positive ub and designated to use negative part or</span>
0950             <span class="comment">%absolute value, simply using the negative of the original variable</span>
0951             options.MC(ub &lt;= 0 &amp; (MCmode(:,j) == 3 | MCmode(:,j) == 2),j) <span class="keyword">...</span>
0952                 = - options.MC(ub &lt;= 0 &amp; (MCmode(:,j) == 3 | MCmode(:,j) == 2),j);
0953             MCmode(ub &lt;= 0 &amp; (MCmode(:,j) == 3 | MCmode(:,j) == 2),j) = 0;
0954         <span class="keyword">end</span>
0955         Vdecomp = find(any(options.MC ~=0 &amp; MCmode ~= 0,2));
0956         nMCrow = numel(Vdecomp);
0957         <span class="comment">%record the index for each new variable and flux</span>
0958         VdecompInd = [(1:n+nSp)', sparse(repmat(Vdecomp(:),2,1),reshape(repmat(1:2,nMCrow,1),2*nMCrow,1),<span class="keyword">...</span>
0959             n+nSp+1:n+nSp+nMCrow*2,n+nSp,2)];
0960         <span class="comment">%new columns for decomposition variables</span>
0961         obj = [obj; zeros(nMCrow*2,1)];
0962         lb = [lb;zeros(nMCrow*2,1)];
0963         ub = [ub;inf(nMCrow*2,1)];
0964         colname = [colname; strcat(modelCom.rxns(Vdecomp),<span class="string">'_pos'</span>);strcat(modelCom.rxns(Vdecomp),<span class="string">'_neg'</span>)];
0965         index.var.vp = nVar + 1 : nVar + nMCrow;
0966         nVar = nVar + nMCrow;
0967         index.var.vn = nVar + 1 : nVar + nMCrow;
0968         nVar = nVar + nMCrow;
0969         ctype = [ctype char(<span class="string">'C'</span> * ones(1, nMCrow*2))];
0970         <span class="comment">%new rows to add ( 0&lt;= V - V_pos + V_neg &lt;= 0)</span>
0971         lhs = [lhs; zeros(nMCrow,1)];
0972         rhs = [rhs; zeros(nMCrow,1)];
0973         <span class="comment">%matrix to update</span>
0974         row = [1:nMCrow, 1:nMCrow, 1:nMCrow];
0975         col = [Vdecomp(:)', n+nSp+1:n+nSp+nMCrow*2];
0976         entry = [ones(1,nMCrow), -ones(1,nMCrow), ones(1,nMCrow)];
0977         A = [A sparse(size(A, 1), nMCrow*2);<span class="keyword">...</span>
0978             sparse(row, col, entry, nMCrow, n + nSp + nMCrow*2)];
0979         rowname = [rowname; strcat(modelCom.rxns(Vdecomp),<span class="string">'_decomp'</span>)];
0980         index.con.decomp = nCon + 1 : nCon + nMCrow;
0981         nCon = nCon + nMCrow;
0982         <span class="comment">%add MC constraints</span>
0983         MCmodeLogic = repmat(struct(<span class="string">'mode'</span>,[]),3,1);
0984         <span class="comment">%MCmode: 0, original flux; 1, +ve flux; 2, -ve flux; 3, absolute flux</span>
0985         <span class="comment">%original variable</span>
0986         MCmodeLogic(1).mode = MCmode == 0 &amp; options.MC ~= 0;
0987         <span class="comment">%positive part</span>
0988         MCmodeLogic(2).mode = (MCmode == 1 | MCmode == 3) &amp; options.MC ~= 0;
0989         <span class="comment">%negative part</span>
0990         MCmodeLogic(3).mode = (MCmode == 2 | MCmode == 3) &amp; options.MC ~= 0;
0991         nMCcon = 0;
0992         <span class="keyword">for</span> j = 1:3
0993             nMCcon = nMCcon + nnz(MCmodeLogic(j).mode);
0994         <span class="keyword">end</span>
0995         <span class="comment">%each original, positive or negative flux 1 entry, each absolute</span>
0996         <span class="comment">%flux 2 entires</span>
0997         [row, col, entry] = deal(zeros(nMCcon , 1));
0998         ct = 0;
0999         ct1 = 0;
1000         <span class="keyword">for</span> j = 1:size(options.MC,2)
1001             <span class="keyword">for</span> k = 1:3
1002                 <span class="comment">%add the corresponding variables into the constraint:</span>
1003                 <span class="comment">%original, positive part and negative part</span>
1004                 nJ = MCmodeLogic(k).mode(:,j);
1005                 col(ct1+1:ct1+sum(nJ)) = VdecompInd(nJ,k);
1006                 entry(ct1+1:ct1+sum(nJ)) = options.MC(nJ,j);
1007                 ct1 = ct1 + sum(nJ);
1008             <span class="keyword">end</span>
1009             row(ct+1:ct1) = j;
1010             ct = ct1;
1011         <span class="keyword">end</span>
1012         lhs = [lhs; MClhs];
1013         rhs = [rhs; MCrhs];
1014         A = [A; sparse(row, col, entry, size(options.MC,2), n + nSp + nMCrow*2)];
1015         rowname = [rowname; strcat(<span class="string">'more_con_'</span>, <span class="keyword">...</span>
1016             strtrim(cellstr(num2str((1:size(options.MC,2))'))))]; 
1017         index.con.mc = nCon + 1 : nCon + size(options.MC,2);
1018         nCon = nCon + size(options.MC,2);
1019     <span class="keyword">end</span>
1020 <span class="keyword">end</span>
1021 
1022 LP.addRows(lhs, [], rhs, char(rowname));
1023 LP.addCols(obj,A,lb,ub,[],char(colname));
1024 
1025 <span class="comment">%% Set Cplex parameters</span>
1026 <span class="comment">% set feasibility and optimality to follow the default setting in COBRA</span>
1027 LP.Param.simplex.tolerances.feasibility.Cur = feasTol;
1028 LP.Param.simplex.tolerances.optimality.Cur = optTol;
1029 <span class="comment">% set parameters given in solverParam. Will override the above two setting</span>
1030 <span class="comment">% if given in solverParam.</span>
1031 [paramList, paramPath] = <a href="#_sub3" class="code" title="subfunction [paramList, paramPath] = getParamList(param, bottomFlag)">getParamList</a>(LP.Param, 0);
1032 [paramUserList, paramUserPath] = <a href="#_sub3" class="code" title="subfunction [paramList, paramPath] = getParamList(param, bottomFlag)">getParamList</a>(solverParam, 1);
1033 paramIden = false(numel(paramUserList), 1);
1034 <span class="keyword">for</span> p = 1:numel(paramUserList)
1035     f = strcmpi(paramList,paramUserList{p});
1036     <span class="keyword">if</span> sum(f) == 1
1037         paramIden(p) = true;
1038         str = [<span class="string">'LP.Param.'</span> paramPath{f} <span class="string">'.Cur = solverParam.'</span> paramUserPath{p} <span class="string">';'</span>];
1039         eval(str);
1040     <span class="keyword">elseif</span> sum(f) &gt; 1
1041         <span class="keyword">if</span> ismember(lower(paramUserPath{p}), paramPath);
1042             paramIden(p) = true;
1043             str = [<span class="string">'LP.Param.'</span> lower(paramUserPath{p}) <span class="string">'.Cur = solverParam.'</span> paramUserPath{p} <span class="string">';'</span>];
1044             eval(str);
1045         <span class="keyword">else</span>
1046             <span class="keyword">if</span> verbFlag
1047                 fprintf(<span class="string">'solverParam.%s cannot be uniquely identified as a valid cplex parameter. Ignore.\n'</span>, paramUserPath{p});
1048             <span class="keyword">end</span>
1049         <span class="keyword">end</span>
1050     <span class="keyword">else</span>
1051         <span class="keyword">if</span> verbFlag
1052             fprintf(<span class="string">'solverParam.%s cannot be identified as a valid cplex parameter. Ignore.\n'</span>, paramUserPath{p});
1053         <span class="keyword">end</span>
1054     <span class="keyword">end</span>
1055 <span class="keyword">end</span>
1056 
1057 <span class="keyword">if</span> ~isempty(saveModel)
1058     LP.writeParam([saveModel <span class="string">'.prm'</span>]);
1059 <span class="keyword">end</span>
1060 
1061 <span class="keyword">end</span>
1062 
1063 <a name="_sub2" href="#_subfunctions" class="code">function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)</a>
1064 <span class="comment">%LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)</span>
1065 <span class="comment">% create the LP problem [LP(grCur)] given growth rate grCur and other</span>
1066 <span class="comment">% constraints if LPproblem as input does not contain the field 'A',</span>
1067 <span class="comment">% or is empty or is not inputted.</span>
1068 <span class="comment">% Otherwise, update LPproblem with the growth rate grCur. Only the</span>
1069 <span class="comment">% arguements 'modelCom', 'grCur', 'GRfx' and 'LPproblem' are used in this</span>
1070 <span class="comment">% case.</span>
1071 <span class="comment">%</span>
1072 <span class="comment">% Input:</span>
1073 <span class="comment">%   modelCom:   community model</span>
1074 <span class="comment">%   grCur:      the current growth rate for the LP to be updated to</span>
1075 <span class="comment">%   GRfx:       fixed growth rate of a certain species</span>
1076 <span class="comment">%   BMcon:      constraint matrix for species biomass</span>
1077 <span class="comment">%   LPproblem:  LP problem structure with field 'A' or the problem matrix</span>
1078 <span class="comment">%               directly</span>
1079 <span class="comment">%   BMgdw:      the gram dry weight per mmol of the biomass reaction of</span>
1080 <span class="comment">%               each species (nSp x 1 vector, default all 1)</span>
1081 <span class="comment">%</span>
1082 <span class="comment">% return a structure with the field 'A' updated if the input 'LPproblem' is</span>
1083 <span class="comment">% a structure or return a matrix if 'LPproblem' is the problem matrix</span>
1084 m = size(modelCom.S, 1);
1085 n = size(modelCom.S, 2);
1086 nRxnSp = sum(modelCom.indCom.rxnSps &gt; 0);
1087 nSp = numel(modelCom.infoCom.spAbbr);
1088 <span class="keyword">if</span> ~exist(<span class="string">'grCur'</span>, <span class="string">'var'</span>)
1089     grCur = 0;
1090 <span class="keyword">elseif</span> isempty(grCur)
1091     grCur = 0;
1092 <span class="keyword">end</span>
1093 <span class="keyword">if</span> ~exist(<span class="string">'GRfx'</span>, <span class="string">'var'</span>)|| isempty(GRfx)
1094     GRfx  = <a href="../SteadyCom/auxiliary_functions/getCobraComParams.html" class="code" title="function varargout = getCobraComParams(param2get, options, modelCom)">getCobraComParams</a>({<span class="string">'GRfx'</span>}, struct(), modelCom);
1095 <span class="keyword">end</span>
1096 <span class="keyword">if</span> ~exist(<span class="string">'LPproblem'</span>, <span class="string">'var'</span>)
1097     LPproblem = struct();
1098 <span class="keyword">end</span>
1099 
1100 construct = false;
1101 <span class="keyword">if</span> ~isstruct(LPproblem)
1102     <span class="keyword">if</span> isempty(LPproblem)
1103         construct = true;
1104     <span class="keyword">end</span>
1105 <span class="keyword">elseif</span> ~isfield(LPproblem, <span class="string">'A'</span>)
1106     construct = true;
1107 <span class="keyword">end</span>
1108 <span class="keyword">if</span> construct
1109     <span class="keyword">if</span> ~exist(<span class="string">'BMgdw'</span>, <span class="string">'var'</span>)
1110         BMgdw = ones(nSp,1);
1111     <span class="keyword">end</span>
1112     <span class="comment">%upper bound matrix</span>
1113     S_ub = sparse([1:nRxnSp 1:nRxnSp]', [(1:nRxnSp)'; n + modelCom.indCom.rxnSps(1:nRxnSp)],<span class="keyword">...</span>
1114           [ones(nRxnSp,1); -modelCom.ub(1:nRxnSp)], nRxnSp, n + nSp);
1115     <span class="comment">%lower bound matrix</span>
1116     S_lb = sparse([1:nRxnSp 1:nRxnSp]', [(1:nRxnSp)'; n + modelCom.indCom.rxnSps(1:nRxnSp)],<span class="keyword">...</span>
1117           [-ones(nRxnSp,1); modelCom.lb(1:nRxnSp)], nRxnSp, n + nSp);
1118     <span class="comment">%growth rate and biomass link matrix</span>
1119     grSp = zeros(nSp, 1);
1120     grSp(isnan(GRfx)) = grCur;
1121     <span class="comment">%given fixed growth rate</span>
1122     grSp(~isnan(GRfx)) = GRfx(~isnan(GRfx));
1123     S_gr = sparse([1:nSp 1:nSp]', [modelCom.indCom.spBm(:) (n + 1:n + nSp)'],<span class="keyword">...</span>
1124                   [BMgdw; -grSp], nSp, n + nSp);
1125     <span class="keyword">if</span> isempty(BMcon)
1126         A = [modelCom.S sparse([],[],[], m, nSp); S_ub; S_lb; S_gr];
1127     <span class="keyword">else</span>
1128         A = [modelCom.S sparse([],[],[], m, nSp); S_ub; S_lb; S_gr;<span class="keyword">...</span>
1129                    sparse([],[],[],size(BMcon, 1), n) BMcon];
1130     <span class="keyword">end</span>
1131     <span class="keyword">if</span> isstruct(LPproblem)
1132         LPproblem.A = A;
1133     <span class="keyword">else</span>
1134         LPproblem = A;
1135     <span class="keyword">end</span>
1136 <span class="keyword">else</span>
1137     <span class="keyword">for</span> j = 1:nSp
1138         <span class="keyword">if</span> isstruct(LPproblem)
1139             <span class="keyword">if</span> isnan(GRfx(j))
1140                 LPproblem.A(m + 2*nRxnSp + j, n + j) = -grCur;
1141             <span class="keyword">else</span>
1142                 LPproblem.A(m + 2*nRxnSp + j, n + j) = -GRfx(j);
1143             <span class="keyword">end</span>
1144         <span class="keyword">else</span>
1145             <span class="keyword">if</span> isnan(GRfx(j))
1146                 LPproblem(m + 2*nRxnSp + j, n + j) = -grCur;
1147             <span class="keyword">else</span>
1148                 LPproblem(m + 2*nRxnSp + j, n + j) = -GRfx(j);
1149             <span class="keyword">end</span>
1150         <span class="keyword">end</span>
1151     <span class="keyword">end</span>
1152 <span class="keyword">end</span>
1153 <span class="keyword">end</span>
1154 
1155 <a name="_sub3" href="#_subfunctions" class="code">function [paramList, paramPath] = getParamList(param, bottomFlag)</a>
1156 <span class="comment">%for matching CPLEX parameters appropriately</span>
1157 structCur = param;
1158 lv = 1;
1159 lvFieldN = zeros(10,1);
1160 lvFieldN(1) = 1;
1161 lvField = cell(10, 1);
1162 lvField{lv} = fieldnames(structCur);
1163 paramPath = {};
1164 paramList = {};
1165 <span class="keyword">while</span> lv &gt; 0
1166     <span class="keyword">if</span> isstruct(structCur.(lvField{lv}{lvFieldN(lv)}))
1167         structCur = structCur.(lvField{lv}{lvFieldN(lv)});
1168         lv = lv + 1;
1169         lvFieldN(lv) = 1;
1170         lvField{lv} = fieldnames(structCur);
1171     <span class="keyword">else</span>
1172         <span class="keyword">if</span> ~bottomFlag
1173             lv = lv - 1;
1174         <span class="keyword">end</span>
1175         <span class="keyword">if</span> lv &gt; 0
1176             c = {};
1177             <span class="keyword">for</span> j = 1:lv
1178                 c = [c lvField{j}(lvFieldN(j))];
1179             <span class="keyword">end</span>
1180             paramPath = [paramPath; strjoin(c,<span class="string">'.'</span>)];
1181             paramList = [paramList; c(end)];
1182             <span class="keyword">while</span> lvFieldN(lv) == numel(lvField{lv})
1183                 lv = lv - 1;
1184                 <span class="keyword">if</span> lv == 0
1185                     <span class="keyword">break</span>
1186                 <span class="keyword">end</span>
1187             <span class="keyword">end</span>
1188             <span class="keyword">if</span> lv &gt; 0
1189                 lvFieldN(lv) = lvFieldN(lv) + 1;
1190                 structCur = param;
1191                 <span class="keyword">for</span> j = 1:lv-1
1192                     structCur = structCur.(lvField{j}{lvFieldN(j)});
1193                 <span class="keyword">end</span>
1194             <span class="keyword">end</span>
1195         <span class="keyword">else</span>
1196             lv = 1;
1197             <span class="keyword">if</span> lvFieldN(lv) == numel(lvField{lv})
1198                 <span class="keyword">break</span>
1199             <span class="keyword">else</span>
1200                 lvFieldN(1) = lvFieldN(1) + 1;
1201             <span class="keyword">end</span>
1202         <span class="keyword">end</span>
1203     <span class="keyword">end</span>
1204 <span class="keyword">end</span>
1205 
1206 <span class="keyword">end</span>
1207 
1208 <a name="_sub4" href="#_subfunctions" class="code">function dBM = LP4fzero1(grCur, LP, modelCom, GRfx, feasTol, BMequiv,BMgdw)</a>
1209     LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, grCur, GRfx, [], LP.Model.A, BMgdw);
1210     LP.solve();
1211     <span class="keyword">if</span> LP.Solution.status == 11
1212         dBM = [];
1213         <span class="keyword">return</span>
1214     <span class="keyword">end</span>
1215     <span class="comment">% check the feasibility of the solution manually</span>
1216     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
1217     <span class="comment">%biomass of the current iteration</span>
1218     BMcur = 0;
1219     <span class="keyword">if</span> isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
1220         <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
1221             BMcur = LP.Model.obj' * LP.Solution.x;
1222         <span class="keyword">end</span>
1223     <span class="keyword">end</span>
1224     dBM = BMequiv - BMcur;
1225 <span class="keyword">end</span>
1226 
1227 <a name="_sub5" href="#_subfunctions" class="code">function dBM = LP4fzero2(grCur, LP, modelCom, GRfx, feasTol, BMequiv, GR0, BMgdw)</a>
1228     LP.Model.A =<a href="../SteadyCom/auxiliary_functions/updateLPcom.html" class="code" title="function LPproblem = updateLPcom(modelCom, grCur, GRfx, BMcon, LPproblem, BMgdw)">updateLPcom</a>(modelCom, grCur, GRfx, [], LP.Model.A, BMgdw);
1229     LP.solve();
1230     <span class="keyword">if</span> LP.Solution.status == 11
1231         dBM = [];
1232         <span class="keyword">return</span>
1233     <span class="keyword">end</span>
1234     <span class="comment">% check the feasibility of the solution manually</span>
1235     dev = <a href="../SteadyCom/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
1236     <span class="comment">%biomass of the current iteration</span>
1237     BMcur = 0;
1238     <span class="keyword">if</span> isfield(LP.Solution, <span class="string">'x'</span>) &amp;&amp; dev &lt;= feasTol
1239         <span class="keyword">if</span> ~any(isnan(LP.Solution.x))
1240             BMcur = LP.Model.obj' * LP.Solution.x;
1241         <span class="keyword">end</span>
1242     <span class="keyword">end</span>
1243     dBM = (BMequiv * GR0 / grCur) - BMcur;
1244 <span class="keyword">end</span>
1245 
1246 <a name="_sub6" href="#_subfunctions" class="code">function yn = ErrBecauseInfeas(ME)</a>
1247 yn = ~isempty(strfind(lower(ME.message),<span class="string">'cplex'</span>)) &amp;&amp; <span class="keyword">...</span>
1248     ~isempty(strfind(lower(ME.message),<span class="string">'error'</span>)) &amp;&amp; <span class="keyword">...</span>
1249     ~isempty(strfind(lower(ME.message),<span class="string">'1256'</span>));
1250 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sat 06-May-2017 09:26:04 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>